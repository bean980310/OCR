--- ABSTRACT ---
특히 소프트웨어 엔지니어링(SE) 작업에서 자동화의 출현은 이론에서 현실로 전환되었습니다. 수많은 학술 논문에서 프로젝트 관리, 모델링, 테스트 및 개발과 같은 분야의 문제를 해결하기 위해 인공 지능을 성공적으로 적용한 사례를 기록했습니다. 최근의 혁신은 다음과 같습니다.
--- INTRODUCTION ---
ChatGPT는 개발자와 테스터를 위해 각각 프로그래밍 코드를 생성하고 소프트웨어 테스트 전략을 수립하는 데 능숙한 리소스로 알려진 ML이 주입된 챗봇입니다. AI 기반 컴퓨팅이 생산성을 높이고 소프트웨어 개발에서 소프트웨어 엔지니어를 대체할 수 있다는 추측이 있지만 현재 이를 검증할 실증적 증거가 부족합니다. 게다가 AI 시스템의 정확성을 높이는 데 주로 초점을 맞추고 있음에도 불구하고 에너지 효율성, 취약성, 공정성(즉, 인간의 편견) 및 안전성을 포함한 비기능적 요구 사항은 종종 충분한 관심을 받지 못합니다. 이 논문은 다양한 평가 기준을 고려하여 소프트웨어 엔지니어와 AI 기반 솔루션을 포괄적으로 비교하는 것이 인간-기계 협업을 촉진하고 AI 기반 방법의 신뢰성을 향상하며 인간 또는 AI에 대한 작업 적합성을 이해하는 데 중요하다고 주장합니다. 또한 협력적 작업 구조와 인간 참여 프로세스의 효과적인 구현을 용이하게 합니다. 이 논문은 다양한 평가 지표에서 소프트웨어 엔지니어와 ChatGPT와 같은 AI 시스템의 성과를 대조하는 실증적 조사를 수행합니다. 경험적 연구에는 ChatGPT에서 생성한 코드와 개발자가 생성하여 Leetcode에 업로드한 코드를 평가하는 사례가 포함됩니다.키워드 소프트웨어 엔지니어링 AI 기반 솔루션 성능 평가 ChatGPT · 머신 러닝 1 서론 OpenAI에서 제공하는 도구인 ChatGPT(버전 3 및 4) [1, 2]와 같은 AI 기반 도구의 인기가 폭발적으로 증가했습니다.ChatGPT는 2023년 1월에 2,500만 명의 일일 방문자와 함께 1억 명의 사용자를 달성하여 가장 빠르게 성장하는 사용자 기록을 세웠습니다.그 결과 ChatGPT에서 지원하는 최근 자동화 기능으로 인해 코딩 및 테스트와 같은 소프트웨어 개발 작업의 자동화를 잠재적으로 증가시켜 [3, 4, 5] 프로그래머가 작업을 보다 효율적으로 만들고 [2] 생산성을 높일 수 있도록 하고, 소프트웨어 개발 작업에서 인간-기계 팀이 어떻게 더 효과적일 수 있는지 평가하는 것과 같은 주제에 대한 관심이 증가했습니다 [6, 7]. 실제로 ChatGPT와 같은 도구는 양과 질 측면에서 인상적인 결과를 가져왔으며, 생성된 결과(예: 코드)는 많은 경우 인간이 생성한 것과 유사합니다.예를 들어, Golzadeh 등은 GitHub의 대규모 오픈소스 프로젝트에서 ChatGPT vs. Human Programmers A PREPRINT 조사를 수행한 결과, 봇이 봇이라는 레이블이 붙지 않고도 가장 적극적으로 기여하는 요소 중 하나임을 관찰했습니다[8].그러나 연구 커뮤니티가 AI 기반 접근 방식의 정확성을 높이기 위해 많은 노력을 기울인 반면, 에너지 효율성[10], 취약성[11], 공정성(즉, 인간의 편견)[12] 및 안전성[5, 13]과 같은 다른 비기능적 요구 사항[9]을 간과하는 경우가 많습니다.Georgiou 등에 따르면[10] 딥 러닝 프레임워크를 사용하면 에너지 소비와 CO2 배출이 상당히 증가했습니다. 예를 들어, &quot;ChatGPT만이 덴마크에서 175,000명이 한 달에 소비하는 전기와 동일한 양을 소비하는 것으로 추산됩니다&quot;[5]. Pearce et al. [11]은 보안 관련 시나리오에서 AI 기반 코드 생성기의 사용을 조사했으며 제공된 솔루션의 40%가 취약하다는 것을 관찰했습니다. Sarro [5]는 광고 및 채용 프로세스와 같은 ML에 의존하는 다양한 실제 시스템에 편향이 존재하고, 새로운 맬웨어를 만들거나 생성된 시스템에 맬웨어를 삽입하는 것과 같은 안전하지 않은 코드 생성 [13], 파일 조작과 같은 위험한 작업 수행 [14] 또는 사기, 괴롭힘, 잘못된 정보 및 선거 간섭과 같은 유해한 행위 촉진과 같은 안전 문제에 주목합니다. Sarro [5]에 따르면, 전문성 수준에 관계없이 소프트웨어 엔지니어조차도 이러한 비기능적 특성을 개선할 수 있는 모든 가능성을 수동으로 감지할 수 없습니다. 또한 AI 기반 계산이 생산성을 높이고 소프트웨어 엔지니어를 대체할 수 있다는 추측이 있지만 소프트웨어 개발에서 현재 이를 검증할 실증적 증거가 부족합니다[7]. 사실, 소프트웨어 엔지니어링에서 머신 러닝 기술의 사용을 조사하고 ML 기반 솔루션을 소프트웨어 엔지니어가 제공한 솔루션과 비교하는 실증적 연구를 제공하는 논문은 거의 없습니다. 특히 다양한 비기능적 속성을 고려합니다. 예를 들어, Nascimento et al.[15]은 사물 인터넷(IoT) 분야에서 소프트웨어 엔지니어와 머신 러닝을 비교하는 실증적 연구를 제시하여 성능 및 재사용 기준을 다루고 &quot;ML이 IoT 전문 소프트웨어 엔지니어가 제공한 솔루션에 비해 애플리케이션의 성능을 향상시킨다고 말할 수 없습니다... 우리 실험에 따르면 어떤 경우에는 소프트웨어 엔지니어가 머신 러닝 알고리즘보다 성과가 좋지만 다른 경우에는 그렇지 않습니다.&quot; &quot;이러한 이해는 AI 절차가 소프트웨어 개발자가 작업을 달성하도록 지원하는 새로운 인간 참여 루프 접근 방식을 실현하는 데 필수적입니다. 인간과 AI 솔루션의 강점과 약점을 고려하는 인간 참여 루프 접근 방식은 소프트웨어 엔지니어링뿐만 아니라 다른 응용 분야에서도 협력적인 인간-기계 작업 또는 팀을 위한 기반을 제공하는 데 기본이 됩니다. 이 논문은 소프트웨어 엔지니어와 AI 시스템을 성능 및 메모리 효율성과 같은 비기능적 요구 사항과 관련하여 비교할 수 있는 방법을 비교하는 실증적 연구[16]를 제시합니다. 실증적 연구에는 ChatGPT에서 생성한 코드와 개발자가 생성하여 Leetcode에 업로드한 코드를 평가하는 사례 연구가 포함되며, 이는 세 단계로 구성됩니다. (i) 우리는 다양한 난이도의 프로그래밍 문제가 포함된 Leetcode의 경연 대회를 선택했습니다. (ii) 우리는 이러한 문제를 ChatGPT에 프롬프트로 사용하여 코드를 생성했습니다. (iii) 우리는 ChatGPT 코드 솔루션을 Leetcode에 업로드하고 성능 및 효율성 메트릭을 기반으로 이전 솔루션과 비교했습니다. 이 논문은 다음과 같이 구성됩니다. 섹션 2에서는
--- RELATED WORK ---
. 섹션 3에서는 연구 질문, 가설 및 연구 목적을 설명하는 경험적 연구를 제시합니다. 섹션 4에서는 실험 결과와 타당성에 대한 위협을 제시합니다. 이 논문은 결론적 발언과 향후 연구에 대한 제안으로 섹션 5에서 끝납니다. 관련 연구 Imai [7]는 AI 기반 계산이 생산성을 높이고 소프트웨어 개발에서 인간 페어 프로그래머를 대체할 수 있다는 추측이 있지만 현재 이를 확인할 경험적 증거가 부족하다고 주장합니다. 실제로 소프트웨어 엔지니어링에서 머신 러닝 기술 사용을 조사하고 ML 기반 솔루션을 소프트웨어 엔지니어가 제공한 솔루션과 비교하는 경험적 연구를 제공하는 논문은 거의 없습니다. 특히 비기능적 속성을 고려합니다 [15]. Imai [7]는 GitHub Copilot을 사용한 페어 프로그래밍과 인간 페어 프로그래밍 간의 생산성과 코드 품질을 비교하기 위해 경험적 연구를 수행했습니다. OpenAI와 GitHub에서 출시한 도구인 GitHub Copilot은 코드 조각을 제공하고 코드의 일부를 자동으로 채워 사용자에게 지식에 따라 지원을 수락하거나 거부할 수 있는 선택권을 제공합니다. 이 실험에는 21명의 참가자가 참여했으며, 각자는 코딩할 프로젝트와 인간 또는 GitHub Copilot인 개발자 파트너를 받았습니다. Imai[7]는 평가를 위해 추가된 코드 줄 수를 기준으로 생산성을 계산하고 추가된 후 제거된 코드 줄 수를 기준으로 코드 품질을 계산했습니다. 결과에 따르면 Copilot으로 프로그래밍하면 같은 기간 동안 인간 페어 프로그래밍보다 더 많은 코드 줄을 생성하는 데 도움이 되었지만 코드 품질은 낮았습니다. 또한 저자는 프로그래머가 인간 페어 프로그래머보다 AI가 생성한 코드를 덜 검사하는 경향이 있다고 보고했기 때문에 코드 신뢰성에 대한 예비 평가를 수행했습니다. Nguyen과 Nadi[17]도 GitHub Copilot에서 생성된 코드를 사용하여 4가지 프로그래밍 언어로 된 33가지 Leetcode 문제에 대한 솔루션의 정확성과 이해 가능성을 평가하는 실증 연구를 수행했습니다. ChatGPT 대 Human Programmers A PREPRINT의 정확성을 평가하기 위해 저자는 각 문제에 대해 통과한 테스트 사례 수를 세었고 이해도를 평가하기 위해 정적 코드 분석을 위한 오픈소스 플랫폼인 SonarQube를 사용하여 복잡성과 인지 복잡성 메트릭을 계산했습니다. 저자는 성능과 메모리 효율성에 초점을 맞추지 않았으므로 각 솔루션에 대한 실행 시간이나 메모리 사용량을 제공하지 않았고 Copilot과 인간이 작성한 솔루션을 비교하지도 않았습니다. Li et al.은 코드 생성 시스템인 AlphaCode[18]를 제시했습니다. 그들은 GitHub 및 CodeContests 데이터를 사용하여 모델을 훈련했습니다. 저자는 AlphaCode를 사용하여 Codeforces 플랫폼의 경쟁 프로그래밍 문제를 해결한 후 &quot;AlphaCode는 5,000명 이상의 참가자가 있는 대회에서 평균 상위 54.3%의 순위를 달성했습니다.&quot;라고 말합니다. 그들은 대회 메트릭을 기반으로 개발자의 솔루션과 비교했는데, 이는 대회에서 남은 시간과 잘못된 제출 페널티의 일부에 불과합니다. Lertbanjongngam et al.[19]은 AlphaCode 평가를 확장했습니다. [18]에서 AlphaCode가 제공한 동일한 코드를 Codeforces 경쟁 프로그래밍 문제에 사용하여 인간과 유사한 코딩 유사성, 성능 및 메모리 효율성을 평가했습니다. 결과에 따르면 AlphaCode에서 생성된 코드는 인간 코드와 유사하여 코드 조각의 10% 미만의 고유성을 갖습니다. 또한 생성된 코드는 인간이 작성한 코드와 비슷하거나 더 낮은 실행 시간과 메모리 사용량을 보입니다. Lertbanjongngam et al. [19]와 대조적으로 첫 번째 실험에는 ChatGpt와 무작위로 선택한 코딩 문제를 사용하여 코드 생성기의 성능을 인간 솔루션의 성능과 비교했습니다. 이 도구는 선택한 각 문제에 대한 코드를 생성하는 데 사용되었습니다. Nascimento et al. [15]는 단위 테스트 세트 없이 코딩 문제의 자동화를 조사하기 위해 실증적 연구를 수행했습니다. 그들의 실험은 특정 단위 테스트 세트를 통과하는 솔루션을 생성하는 것과 같은 일치 기반 메트릭에 의존하지 않습니다. 대신 솔루션이 효율적으로 작동해야 한다는 것을 강조하는 기능적 정확성을 기반으로 합니다. 또한, 그들의 실험은 비지도 ML 기반 접근 방식을 채택하는데, 여기서 ML 접근 방식은 소프트웨어 엔지니어에게 제시되기 전에 문제에 대한 해결책을 제공합니다.3 실험: ChatGPT 대 프로그래머 - 성능과 효율성을 다루는 실증적 연구 소프트웨어 엔지니어는 문제 해결 코딩 능력에 따라 끊임없이 평가를 받는데, 여기에는 문제 사양에 따라 문제를 해결하는 프로그램을 만드는 것이 포함됩니다. 문제가 주어지면, 그들은 무엇이 요구되는지 이해하고 문제를 해결하기 위한 코드를 작성할 수 있어야 합니다. 수년 동안, 이런 종류의 작업은 구직 면접과 프로그래밍 경연 대회에서 소프트웨어 엔지니어를 순위를 매기는 데 사용되었습니다. 그들의 평가는 일반적으로 올바른 솔루션의 수, 솔루션의 성능, 메모리 효율성 및 개발 시간에 의존합니다. 거의 76년 동안 연구자들은 &quot;자동 프로그래밍&quot;[20]이라는 개념에 대해 글을 써왔습니다. Generative Pre-trained Transformer(GPT) 시리즈와 같은 언어 모델의 최근 발전은 코드 생성, 프로그램 합성, 코드 완성 및 버그 감지를 가능하게 함으로써 자동 프로그래밍 분야를 크게 발전시켰습니다. GPT는 방대한 양의 자연어 텍스트로 사전 학습된 다음 질문 답변과 같은 특정 작업에 맞게 미세 조정된 딥 신경망입니다. 작업에 대한 자연어 설명이 주어지면 GPT는 원하는 작업을 수행하는 코드를 생성할 수 있으며, 이는 방대한 코드 코퍼스에서 모델을 미세 조정하여 달성됩니다. OpenAI의 Codex는 GPT 아키텍처를 기반으로 구축되어 ChatGPT에 통합된 언어 모델입니다. Chen et al.[13]은 Codex를 소개하고 소개, 인터뷰 및 경쟁 문제를 포함하여 163개의 코딩 문제 데이터 세트를 사용하여 평가했습니다. 평가는 많은 솔루션을 생성하고 적어도 하나가 단위 테스트를 통과했는지 확인하는 것으로 구성되었습니다. 따라서 문제당 100개의 샘플을 생성한 후, 그들의 솔루션은 문제의 77.5%를 해결할 수 있었습니다.그들은 성능에 접근하는 것이 아니라 효능(통과한 테스트 수)과 메모리 효율성을 기반으로 접근 방식을 평가했습니다.Imai[7], Nguyen과 Nadi[17]도 Codex 버전으로 실증적 연구를 수행했습니다.그들이 평가한 비기능적 요구 사항은 생산성, 코드 품질, 신뢰성, 정확성 및 이해성입니다.섹션 2에서 그들의 연구 결과를 설명합니다.3.1 목표 이러한 맥락에서 우리는 다음과 같은 질문을 하기로 했습니다. &quot;소프트웨어 엔지니어는 성능과 메모리 효율성 측면에서 AI 솔루션과 어떻게 비교됩니까?&quot; 이 질문을 탐구하기 위해 우리는 목표 활동으로 코딩 문제를 선택하고 숙련된 콘테스트 프로그래머가 제공한 솔루션과 ChatGPT가 제공한 솔루션을 비교했습니다.간단히 말해, 그림 1은 이 논문에서 조사하는 이론[21]을 보여줍니다.이 이론에 따르면 우리가 분리하여 측정하려는 변수는 세 가지 종류의 솔루션에서 달성한 성능과 메모리 효율성입니다.i) ChatGPT가 제공한 솔루션; ii) 경험자 콘테스트 프로그래머가 제공한 솔루션; iii) 초보 또는 비콘테스트 프로그래머가 제공한 솔루션.배우 프로그래머 ChatGPT 대 인간 프로그래머 기술은 솔루션을 생성합니다.경험자 콘테스트 프로그래머는 초보자 또는 비콘테스트 프로그래머보다 솔루션을 더 잘 생성합니다.ChatGPT 개선 개선 활동 프로그래밍 문제를 해석하고 코드 솔루션을 작성합니다.소프트웨어 시스템 코딩 문제 쉬움 보통 어려움 성능 사전 인쇄 메모리 효율성 그림 1: 이론[21]: ChatGPT는 더 높은 성능과 메모리 효율성으로 문제 해결 코딩 작업에서 프로그래머보다 우수한 성과를 보입니다.이러한 변수 간의 관계를 평가하기 위해 프로그래밍 인터뷰 준비를 위한 잘 확립된 온라인 플랫폼인 LeetCode를 사용하여 통제된 실험을 수행한 후 ChatGPT에서 제시한 솔루션을 소프트웨어 엔지니어가 이전에 개발한 솔루션과 병치했습니다.다음 하위 섹션에서는 연구 질문(RQx)과 이론의 명제를 설명합니다.이 실험을 수행하기 위해 새로운 코딩 문제가 있는 Leetcode의 가장 최근 콘테스트 중 하나를 선택했습니다¹. 그런 다음 이러한 문제를 ChatGPT의 프롬프트로 사용하여 코드를 생성했습니다. 그런 다음 ChatGPT에서 생성한 코드를 Leetcode에 업로드하여 성능 및 효율성 메트릭을 활용하여 기존 솔루션과 비교했습니다. Leetcode가 제출된 솔루션을 동일한 문제에 대한 모든 이전 솔루션과 비교한다는 점을 감안하여 프로그래머의 전문성을 전제로 이러한 메트릭에 대한 논의를 시작했습니다. 이를 위해 대회에서의 순위에 따라 구분된 42명의 프로그래머 그룹을 선택하고 Leetcode에서 이미 참가한 프로그래밍 대회 수에 따라 분류했습니다. 3.2 질문과 가설 문제 해결 코딩 분야에서 ChatGPT 솔루션의 결과는 다음에서 제공하는 솔루션과 어떻게 다릅니까? RQ1. ...경험이 풍부한 대회 프로그래머가 성능과 관련하여 쉬운, 보통 또는 어려운 코딩 문제를 해결하는 동안? RQ2. ...경험이 풍부한 대회 프로그래머가 메모리 효율성과 관련하여 쉬운, 보통 또는 어려운 코딩 문제를 해결하는 동안? RQ3. ...초보 콘테스트 프로그래머가 쉬운, 보통 또는 어려운 코딩 문제를 풀면서 메모리 효율성에 대해 어떻게 생각하십니까? RQ4. ...초보 콘테스트 프로그래머가 쉬운, 보통 또는 어려운 코딩 문제를 풀면서 메모리 효율성에 대해 어떻게 생각하십니까? 각 RQ는 다음에 설명되는 하나 이상의 가설을 기반으로 합니다. H - RQ1. • HO. ChatGPT는 숙련된 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 성능을 개선하지 않습니다. • HA. ChatGPT는 숙련된 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 성능을 개선합니다. &#39;콘테스트 설명은 https://leetcode.com/contest/biweekly-contest-103/에서 확인할 수 있습니다(2023년 5월 15일 접속) ChatGPT 대 인간 프로그래머 사전 인쇄 H - RQ2. • HO. ChatGPT는 숙련된 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 메모리 효율성을 개선하지 않습니다. • HA. ChatGPT는 숙련된 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 메모리 효율성을 개선합니다. H - RQ3. • HO. ChatGPT는 초보 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 성능을 개선하지 않습니다. • HA. ChatGPT는 초보 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 성능을 개선합니다. H - RQ4. • HO. ChatGPT는 초보 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 메모리 효율성을 개선하지 않습니다. • HA. ChatGPT는 초보 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 메모리 효율성을 개선합니다. 3.3 연구 대상: ChatGPT 개발자는 ChatGPT를 사용하여 그림 2와 같이 자연어 입력에서 코드를 생성할 수 있습니다. 시스템은 코드 외에도 시간 및 공간 복잡도 분석과 같이 생성된 코드에 대한 설명 및 평가를 제공할 수도 있습니다. NM 문자열을 반전하는 C++ 함수를 작성합니다. 모델: GPT-물론, `std::string 클래스를 사용하여 문자열을 반전하는 간단한 C++ 함수가 있습니다. cpp #include<string> std::string reverseString(const std::string&amp; str) { std::string reversedStr = str; int n = str.size();B for(int i = 0; i &lt; n / 2; i++) { std::swap(reversed Str[i], reversedStr[n - i 1]); } return reversedStr; } 응답 재생성 코드 복사 메시지 보내기. ChatGPT는 사람, 장소 또는 사실에 대한 부정확한 정보를 생성할 수 있습니다. ChatGPT 5월 12일 버전 그림 2: ChatGPT를 사용하여 코딩 문제를 해결하는 예. ChatGPT 대 인간 프로그래머 사전 인쇄 ChatGPT는 광범위한 프로그래밍 언어(Java, Kotlin, Python, C++, JavaScript, TypeScript, PHP, Go-lang, Ruby, Swift 등)에 대한 기능적 코드를 생성할 수 있지만, 우리는 C++에 중점을 두기로 했습니다. 이 결정은 C++가 가장 노련한 콘테스트 프로그래머가 주로 사용한다는 사실에 의해 내려졌습니다.우리는 ChatGPT-4를 사용하여 코드 솔루션을 생성했습니다.3.4 통제 실험 실험의 초기 단계에는 코딩 솔루션을 선택하고 구현할 플랫폼을 선택하는 것이 포함되었습니다.우리의 목표는 동일한 애플리케이션에 두 세트의 솔루션을 모두 제시하고 동일한 평가 프로세스를 사용하여 결과를 평가하는 것이었습니다.우리는 코딩 인터뷰 준비를 위한 온라인 플랫폼인 Leetcode를 선택했습니다.백만 명 이상의 사용자가 있으며 2,000개 이상의 코딩 문제와 솔루션을 제공하며, 일반적으로 대형 기술 회사에서 개발자의 기술을 평가하고 인터뷰를 수행하는 데 사용합니다.Leetcode는 성능(런타임 실행)과 메모리 사용량을 기준으로 솔루션을 비교합니다.우리는 Leetcode에서 가장 최근의 프로그래밍 콘테스트 중 하나를 선택했는데, 이 콘테스트는 쉬운 문제 1개, 보통 문제 2개, 어려운 문제 1개로 분류된 4개의 고유한 프로그래밍 과제를 제시했습니다.17,137명의 참가자 중 12,493명이 적어도 하나의 문제를 풀었습니다. 두 가지 문제를 푼 사람의 경우 그 수는 10,733으로 감소했고, 세 가지 문제를 푼 사람의 경우 7,133으로 더 감소했으며, 네 가지 문제 모두에서 단 700명으로 줄었습니다.그림 1에서 볼 수 있듯이, 우리가 분리하여 정량화하려는 요소 중 하나는 프로그래머의 기술 수준에 대한 솔루션의 성능과 메모리 효율성입니다.이를 위해 우리는 대회에서의 순위에 따라 프로그래머를 선택했으며, C++를 사용하고 가장 높은 순위에서 가장 낮은 순위까지 최소 세 가지 문제를 풀 수 있는 사람을 선택했습니다.LeetCode의 매개변수를 활용하여, 이들을 경험이 풍부한 대회 프로그래머와 초보 또는 비대회 프로그래머의 두 가지 범주로 나누었습니다.궁극적으로, 우리는 ChatGPT에서 생성한 솔루션의 성능과 메모리 효율성을 두 참가자 그룹이 제공한 솔루션과 병치했습니다.3.4.1 참가자 분석 그림 3은 LeetCode에서의 순위 수준에 따른 참가자의 분포 그래프를 보여줍니다.수준이 낮을수록 더 경험이 풍부한 프로그래머를 나타냅니다. 예를 들어, 선정된 프로그래머 중 8명은 LeetCode의 순위에 따르면 상위 1%에 속합니다.최고 평점 개발자(%)최고 평점(%)개발자 그림 3: LeetCode 글로벌 순위에 따른 참가자 분포.상위 30%의 프로그래머는 수많은 대회에 참여하여 문제 해결, 알고리즘적 사고 및 코딩 언어에 능숙한 숙련된 대회 프로그래머로 그룹화되었습니다.그들은 시간 압박 속에서도 문제를 빠르게 이해하고 해결하는 데 능숙합니다.나머지 참가자는 초보 또는 비대회 프로그래머로 분류되었으며, 이들의 전문성은 설계, 코딩, 테스트 및 디버깅과 같은 소프트웨어 개발 작업에 더 많이 있습니다.복잡한 문제를 해결할 수 있는 능력에도 불구하고 경쟁적 코딩에 덜 노출되어 대회 프로그래머의 속도와 전문적인 알고리즘 지식이 부족할 수 있습니다.ChatGPT 대 인간 프로그래머 사전 인쇄 3.4.2 실험: ChatGPT에서 제공한 솔루션 우리는 대회 내의 각 문제에 대한 솔루션을 공식화하기 위해 ChatGPT-4를 사용했습니다.². 원래 문제의 설명은 문제 해석을 단순화하기 위한 텍스트 수정 없이 프롬프트로 사용되었습니다.표 3.4.2는 각 솔루션의 성능 및 메모리 효율성과 함께 문제 목록을 요약한 것입니다.LeetCode 플랫폼에서 솔루션을 실행하면 런타임 및 메모리 효율성에 대한 데이터가 생성됩니다.또한 각 질문에 대한 글로벌 순위를 제공하여 성능 및 메모리 효율성 측면에서 이 솔루션보다 성능이 뛰어난 솔루션의 비율을 나타냅니다.이러한 결과는 LeetCode의 처리 수요에 따라 변동될 수 있습니다.시간 변화가 중요하지 않도록 동일한 솔루션을 여러 번 실행했습니다.또한 솔루션의 시간 및 공간 복잡도를 평가했습니다.흥미롭게도 특정 솔루션이 우수한 시간 복잡도 분석을 보여주었음에도 불구하고 다른 솔루션은 우수한 런타임 성능과 메모리 효율성을 보였습니다.이 예는 가장 간단한 문제에 대해 제공된 두 가지 솔루션에서 명확하게 입증됩니다.애플리케이션의 성능을 최적화하는 것은 알고리즘의 반복을 최소화하는 것뿐만 아니라 가장 효과적인 데이터 구조를 선택하는 것에 달려 있다는 것은 알려져 있습니다. 문제 이름 난이도 언어 작동한 솔루션 실패한 경우 테스트 사례 수 런타임 메모리(ms) (MB) 성능 메모리(비트) (비트) (%) (%) ID 시간 공간 복잡도 복잡도 LeetCode 제출 2656. Easy C++ 1/정확히 K개의 요소로 최대 합 2656.70.70.68.O(n log n + k^2 log n) O(n)최대 합 Easy C++ 2/71.21.12.O(n + k* log n) O(n)정확히 K개의 요소로 2657. 접두사 찾기 중간 C++ 1/80.78.97.O(n^3) O(n)두 배열의 공통 배열 2658. 최대 개수 중간 C++ 1/88.69.88.O((mn)²) O(mn)격자 안의 물고기 2659. 어렵게 만들기 C++505/배열 비어 있음 O(n^2) O(n)표 1: ChatGPT에서 제공한 코딩 솔루션의 결과 분석. 일부 문제의 경우 ChatGPT-4는 첫 번째 시도에서 작동하는 솔루션을 성공적으로 생성했습니다. 그러나 다른 문제의 경우 모든 테스트 사례를 통과할 수 있는 솔루션을 생성하려면 여러 번 반복해야 했습니다. 여러 소프트웨어 개발자도 Leetcode에서 수락하여 모든 테스트 사례를 통과하는 솔루션을 생성하기 전에 여러 솔루션을 제출해야 했다는 점이 주목할 만합니다. 가장 어려운 문제는 잘 풀리지 않았고, 생성된 50개가 넘는 솔루션(다양한 프로그래밍 언어로 작성) 중 어느 것도 모든 테스트 사례를 통과할 수 없었습니다. 이 경우 ChatGPT에서 생성한 가장 효과적인 솔루션은 514개 테스트 사례 중 505개를 통과했지만, 더 큰 입력에 대한 시간 제한 초과로 인해 실패했습니다. 이 질문의 미묘함은 배열에서 요소를 제거하는 알고리즘에 대한 텍스트 설명의 제안과 솔루션이 반드시 요소의 삭제나 이동을 필요로 하지 않고 대신 배열 길이에 초점을 맞춘다는 힌트 간의 역설에 있다고 가정합니다. 기본적으로 개발자의 솔루션은 문제 설명의 직접적인 해석과 다를 것으로 예상됩니다.Sobania et al.[22]은 다른 유사한 솔루션과 비교하여 ChatGPT의 코드 생성 기능을 평가하면서 자동화된 솔루션으로 해결할 수 없는 여러 문제는 인간 프로그래머가라도 확실하게 해결하기에는 너무 모호한 문제 설명으로 특징지어졌다고 언급했습니다.2제공된 프롬프트 및 코드 솔루션은 다음에서 사용할 수 있습니다.Google Drive 양식(2023년 5월 15일 액세스)ChatGPT 대 인간 프로그래머 사전 인쇄 3.5 실험 - 결과 표 3.4.2에 자세히 설명된 대로 ChatGPT-4에서 생성한 솔루션은 각 문제에 대한 기존 솔루션의 70.22%, 78.35%, 69.14%를 능가합니다.메모리 효율성 측면에서 ChatGPT-4에서 제공한 솔루션은 각각 68.69%, 97.47%, 88.14%를 능가합니다. 그러나 이 비교는 이전에 제공된 모든 솔루션을 포함하므로 이러한 자동화된 솔루션이 다양한 전문 지식 수준의 소프트웨어 엔지니어와 관련하여 어떻게 수행되는지에 대한 명확성이 부족합니다. 우리는 두 개발자 그룹이 제공한 솔루션을 실행하여 코드의 특정 런타임 및 메모리 효율성을 확인했습니다. 표 2는 개발자가 가장 복잡하지 않은 문제에 대해 생성한 솔루션에서 파생된 결과의 일부를 보여줍니다. 표 3, 4 및 5는 각각 쉬운 문제, 첫 번째 중간 문제 및 두 번째 중간 문제에 대해 선택된 참가자가 제공한 솔루션만을 고려하여 이를 해결합니다 ³. 그룹 개발자 글로벌 C++ 문제 수 순위 대회 TOR 런타임 메모리 위치(%) (ms) (MB) 해결됨 성능(비트) (%) 메모리(비트) (%) A0.70.98.29.A0.3770.93.68.A2,1.1770.30.29.B334,61785.1770.9.68.B351,78989.4570.21.13.B354,53590.1470.52.29.표 2: 선택된 참가자(그룹 A = 숙련자, B = 초보자)가 쉬운 문제에 대해 응답한 것에서 얻은 솔루션 인스턴스 선택. 변수 정도 N개의 표본 자유도 런타임 메모리 t 임계값(.99%) 런타임 런타임 런타임 메모리 메모리 메모리 최적 값 평균(n-1) 표준 편차 t 통계량 최적 값 평균 표준 프로그래머-2.54.16.-2.70.71.2.t 통계량 -1.경험자 경연대회-2.21.-1.70.72.3.-1.프로그래머 초보자 경연대회-2.54.8.-3.70.70.0.-1.프로그래머 ChatGPT-70.표 3: 쉬운 문제(2656. 정확히 K개의 요소로 최대 합계): 검정 통계량을 수행할 데이터 - 성능 및 메모리 효율성. 변수 정도 N개의 표본 자유도(n-1) 런타임 메모리 t 임계값(.99%) 런타임 런타임 런타임 프로그래머 숙련-2.최상의 값 평균 118.표준 편차 123.t통계 최상의 값 평균 -3.80.91.표준 24.메모리 메모리 메모리 t통계 -2.경연-2.83.67.-2.80.87.15.-1.프로그래머 초보자 경연-2.162.161.-2.81.95.31.-1.프로그래머 ChatGPT-80.표 4: 중간 문제(2657. 두 배열의 접두사 공통 배열 찾기): 테스트를 수행하기 위한 데이터 통계 성능 및 메모리 효율성.난이도가 높은 문제와 관련하여 ChatGPT와 초보자 경연 프로그래머 모두 해결하지 못한 채 남았습니다.숙련된 경연 프로그래머만이 이 코딩 문제에 대한 효과적인 솔루션을 제공하는 데 성공했습니다. ³ 각 참가자가 제공한 코드와 제출 링크는 다음에서 사용할 수 있습니다.Google Drive 양식(2023년 5월 15일 접속)ChatGPT 대 인간 프로그래머 A 사전 인쇄 학위 런타임 t 임계 런타임 런타임 메모리 런타임 메모리 N 메모리 변수 샘플 메모리 자유도 값(.99%) 최적 값 평균(n-1) 프로그래머-2.154.표준 편차 95.최상 t 통계량 평균 표준 t 통계량 값 -4.88.110.26.-4.경험자 경연 대회-2.138.102.-2.88.105.26.-2.프로그래머 초보자 경연 대회-2.178.81.-4.88.118.26.-4.프로그래머 ChatGPT-88.표 5: 중간 문제(2658. 그리드의 최대 물고기 수): 검정 통계를 수행하기 위한 데이터 - 성능 및 메모리 효율성. 3.5.1 가설 검정 이 부분에서는 3.2절에서 소개한 솔루션 성능 및 메모리 효율성 평가에 관한 가설을 조사합니다. 결과적으로 우리는 통계 분석을 수행했습니다.
--- METHOD ---
s, 인간 또는 AI에 대한 작업 적합성을 이해합니다.또한 협력적 작업 구조와 인간 참여 프로세스의 효과적인 구현을 용이하게 합니다.이 논문은 경험적 조사를 수행하여 다양한 평가 지표에서 소프트웨어 엔지니어와 ChatGPT와 같은 AI 시스템의 성과를 대조합니다.경험적 연구에는 ChatGPT에서 생성한 코드와 개발자가 생성하여 Leetcode에 업로드한 코드를 평가하는 사례가 포함됩니다.키워드 소프트웨어 엔지니어링 AI 기반 솔루션 성능 평가 ChatGPT · 머신 러닝 1 서론 OpenAI에서 제공하는 도구인 ChatGPT(버전 3 및 4) [1, 2]와 같은 AI 기반 도구의 인기가 폭발적으로 증가했습니다.ChatGPT는 가장 빠르게 성장하는 사용자 기록을 세웠으며, 2023년 1월에 1억 명의 사용자를 확보했고 일일 방문자는 2,500만 명이었습니다. 그 결과, ChatGPT가 지원하는 최근 자동화 기능으로 인해 코딩 및 테스트와 같은 소프트웨어 개발 작업의 자동화를 잠재적으로 증가시켜[3, 4, 5] 프로그래머가 작업을 보다 효율적으로[2] 수행하고 생산성을 높일 수 있게 하고, 소프트웨어 개발 작업에서 인간-기계 팀이 어떻게 더 효과적일 수 있는지 평가하는 것과 같은 주제에 대한 관심이 증가했습니다[6, 7]. 실제로 ChatGPT와 같은 도구는 양과 질 측면에서 인상적인 결과를 가져왔으며 생성된 결과(예: 코드)는 많은 경우 인간이 생성한 것과 비슷합니다. 예를 들어, Golzadeh 등은 GitHub의 대규모 오픈소스 프로젝트에서 ChatGPT vs. Human Programmers A PREPRINT 조사를 수행했고, 봇이라는 레이블이 붙지 않고도 봇이 가장 적극적으로 기여하는 요소 중 하나라는 것을 관찰했습니다[8]. 그러나 연구 커뮤니티가 AI 기반 접근 방식의 정확성을 높이기 위해 많은 노력을 기울인 반면, 에너지 효율성[10], 취약성[11], 공정성(즉, 인간의 편견)[12] 및 안전성[5, 13]과 같은 다른 비기능적 요구 사항[9]을 종종 간과했습니다. Georgiou et al.[10]에 따르면, 딥 러닝 프레임워크를 사용하면 에너지 소비와 CO2 배출량이 상당히 증가했습니다. 예를 들어, &quot;ChatGPT만이 덴마크에서 175,000명이 한 달에 소비하는 전기와 동일한 양을 소비하는 것으로 추산됩니다&quot;[5]. Pearce et al. [11]은 보안 관련 시나리오에서 AI 기반 코드 생성기의 사용을 조사했으며 제공된 솔루션의 40%가 취약하다는 것을 관찰했습니다. Sarro [5]는 광고 및 채용 프로세스와 같은 ML에 의존하는 다양한 실제 시스템에 편향이 존재하고, 새로운 맬웨어를 만들거나 생성된 시스템에 맬웨어를 삽입하는 것과 같은 안전하지 않은 코드 생성 [13], 파일 조작과 같은 위험한 작업 수행 [14] 또는 사기, 괴롭힘, 잘못된 정보 및 선거 간섭과 같은 유해한 행위 촉진과 같은 안전 문제에 주목합니다. Sarro [5]에 따르면, 전문성 수준에 관계없이 소프트웨어 엔지니어조차도 이러한 비기능적 특성을 개선할 수 있는 모든 가능성을 수동으로 감지할 수 없습니다. 또한 AI 기반 계산이 생산성을 높이고 소프트웨어 엔지니어를 대체할 수 있다는 추측이 있지만 소프트웨어 개발에서 현재 이를 검증할 실증적 증거가 부족합니다[7]. 사실, 소프트웨어 엔지니어링에서 머신 러닝 기술의 사용을 조사하고 ML 기반 솔루션을 소프트웨어 엔지니어가 제공한 솔루션과 비교하는 실증적 연구를 제공하는 논문은 거의 없습니다. 특히 다양한 비기능적 속성을 고려합니다. 예를 들어, Nascimento et al.[15]은 사물 인터넷(IoT) 분야에서 소프트웨어 엔지니어와 머신 러닝을 비교하는 실증적 연구를 제시하여 성능 및 재사용 기준을 다루고 &quot;ML이 IoT 전문 소프트웨어 엔지니어가 제공한 솔루션과 비교하여 애플리케이션의 성능을 향상시킨다고 말할 수 없습니다... 우리의
--- EXPERIMENT ---
&#39;어떤 경우에는 소프트웨어 엔지니어가 머신 러닝 알고리즘보다 성과가 좋지만, 다른 경우에는 그렇지 않다는 것을 보여줍니다.&#39; &quot;이러한 이해는 AI 절차가 소프트웨어 개발자가 작업을 달성하도록 지원하는 새로운 인간 참여 루프 접근 방식을 실현하는 데 필수적입니다. 인간과 AI 솔루션의 강점과 약점을 고려하는 인간 참여 루프 접근 방식은 소프트웨어 엔지니어링뿐만 아니라 다른 응용 분야에서도 협력적인 인간-기계 작업 또는 팀을 위한 기반을 제공하는 데 기본이 됩니다. 이 논문은 소프트웨어 엔지니어와 AI 시스템을 성능 및 메모리 효율성과 같은 비기능적 요구 사항과 관련하여 비교할 수 있는 방법을 비교하는 실증적 연구[16]를 제시합니다. 실증적 연구에는 ChatGPT에서 생성한 코드와 개발자가 생성하여 Leetcode에 업로드한 코드를 평가하는 사례 연구가 포함되며, 이는 세 단계로 구성됩니다. (i) 우리는 다양한 난이도의 프로그래밍 문제가 포함된 Leetcode의 경연 대회를 선택했습니다. (ii) 우리는 이러한 문제를 ChatGPT에 대한 프롬프트로 사용하여 코드를 생성했습니다. (iii) 우리는 ChatGPT 코드 솔루션을 Leetcode에 업로드하고 성능 및 효율성 메트릭을 기반으로 이전 솔루션과 비교했습니다. 이 논문은 다음과 같이 구성됩니다. 섹션 2에서는 관련 작업을 제시합니다. 섹션 3에서는 연구 질문, 가설 및 연구 목적을 설명하는 실증적 연구를 제시합니다.섹션 4에서는 실험 결과와 타당성에 대한 위협을 제시합니다.논문은 결론적 발언과 향후 연구에 대한 제안으로 섹션 5에서 끝납니다.관련 연구 Imai [7]는 AI 기반 계산이 생산성을 높이고 소프트웨어 개발에서 인간 페어 프로그래머를 대체할 수 있다는 추측이 있지만 현재 이를 확인할 실증적 증거가 부족하다고 주장합니다.사실, 소프트웨어 엔지니어링에서 머신 러닝 기술의 사용을 조사하고 ML 기반 솔루션을 소프트웨어 엔지니어가 제공한 솔루션과 비교하는 실증적 연구를 제공하는 논문은 거의 없습니다.특히 비기능적 속성을 고려합니다.[15] Imai [7]는 GitHub Copilot을 사용한 페어 프로그래밍과 인간 페어 프로그래밍 간의 생산성과 코드 품질을 비교하기 위해 실증적 연구를 수행했습니다. OpenAI와 GitHub에서 출시한 도구인 GitHub Copilot은 코드 조각을 제공하고 코드의 일부를 자동으로 채워 사용자에게 지식에 따라 지원을 수락하거나 거부할 수 있는 선택권을 제공합니다. 이 실험에는 21명의 참가자가 참여했으며, 각자는 코딩할 프로젝트와 인간 또는 GitHub Copilot인 개발자 파트너를 받았습니다. Imai[7]는 평가를 위해 추가된 코드 줄 수를 기준으로 생산성을 계산하고 추가된 후 제거된 코드 줄 수를 기준으로 코드 품질을 계산했습니다. 결과에 따르면 Copilot으로 프로그래밍하면 같은 기간 동안 인간 페어 프로그래밍보다 더 많은 코드 줄을 생성하는 데 도움이 되었지만 코드 품질은 낮았습니다. 또한 저자는 프로그래머가 인간 페어 프로그래머보다 AI가 생성한 코드를 덜 검사하는 경향이 있다고 보고했기 때문에 코드 신뢰성에 대한 예비 평가를 수행했습니다. Nguyen과 Nadi[17]도 GitHub Copilot에서 생성된 코드를 사용하여 4가지 프로그래밍 언어로 된 33가지 Leetcode 문제에 대한 솔루션의 정확성과 이해 가능성을 평가하는 실증 연구를 수행했습니다. ChatGPT 대 Human Programmers A PREPRINT의 정확성을 평가하기 위해 저자는 각 문제에 대해 통과한 테스트 사례 수를 세었고 이해도를 평가하기 위해 정적 코드 분석을 위한 오픈소스 플랫폼인 SonarQube를 사용하여 복잡성과 인지 복잡성 메트릭을 계산했습니다. 저자는 성능과 메모리 효율성에 초점을 맞추지 않았으므로 각 솔루션에 대한 실행 시간이나 메모리 사용량을 제공하지 않았고 Copilot과 인간이 작성한 솔루션을 비교하지도 않았습니다. Li et al.은 코드 생성 시스템인 AlphaCode[18]를 제시했습니다. 그들은 GitHub 및 CodeContests 데이터를 사용하여 모델을 훈련했습니다. 저자는 AlphaCode를 사용하여 Codeforces 플랫폼의 경쟁 프로그래밍 문제를 해결한 후 &quot;AlphaCode는 5,000명 이상의 참가자가 있는 대회에서 평균 상위 54.3%의 순위를 달성했습니다.&quot;라고 말합니다. 그들은 대회 메트릭을 기반으로 개발자의 솔루션과 비교했는데, 이는 대회에서 남은 시간과 잘못된 제출 페널티의 일부에 불과합니다. Lertbanjongngam et al.[19]은 AlphaCode 평가를 확장했습니다. [18]에서 AlphaCode가 제공한 동일한 코드를 Codeforces 경쟁 프로그래밍 문제에 사용하여 인간과 유사한 코딩 유사성, 성능 및 메모리 효율성을 평가했습니다. 결과에 따르면 AlphaCode에서 생성된 코드는 인간 코드와 유사하여 코드 조각의 10% 미만의 고유성을 갖습니다. 또한 생성된 코드는 인간이 작성한 코드와 비슷하거나 더 낮은 실행 시간과 메모리 사용량을 보입니다. Lertbanjongngam et al. [19]와 대조적으로 첫 번째 실험에는 ChatGpt와 무작위로 선택한 코딩 문제를 사용하여 코드 생성기의 성능을 인간 솔루션의 성능과 비교했습니다. 이 도구는 선택한 각 문제에 대한 코드를 생성하는 데 사용되었습니다. Nascimento et al. [15]는 단위 테스트 세트 없이 코딩 문제의 자동화를 조사하기 위해 실증적 연구를 수행했습니다. 그들의 실험은 특정 단위 테스트 세트를 통과하는 솔루션을 생성하는 것과 같은 일치 기반 메트릭에 의존하지 않습니다. 대신 솔루션이 효율적으로 작동해야 한다는 것을 강조하는 기능적 정확성을 기반으로 합니다. 또한, 그들의 실험은 ML 기반 비지도 접근 방식을 채택하는데, 여기서 ML 접근 방식은 소프트웨어 엔지니어에게 제시되기 전에 문제에 대한 해결책을 제공합니다. 3 실험: ChatGPT 대 프로그래머 - 성능과 효율성을 다루는 실증적 연구 소프트웨어 엔지니어는 문제 해결 코딩 능력에 따라 끊임없이 평가를 받습니다. 여기에는 문제 사양에 따라 문제를 해결하는 프로그램을 만드는 것이 포함됩니다. 문제가 주어지면, 그들은 무엇이 요구되는지 이해하고 문제를 해결하기 위한 코드를 작성할 수 있어야 합니다. 수년 동안, 이런 종류의 작업은 구직 면접과 프로그래밍 경연 대회에서 소프트웨어 엔지니어를 순위를 매기는 데 사용되었습니다. 그들의 평가는 일반적으로 올바른 솔루션의 수, 솔루션의 성능, 메모리 효율성 및 개발 시간에 의존합니다. 거의 76년 동안 연구자들은 &quot;자동 프로그래밍&quot;[20]이라는 개념에 대해 글을 써왔습니다. Generative Pre-trained Transformer(GPT) 시리즈와 같은 언어 모델의 최근 발전은 코드 생성, 프로그램 합성, 코드 완성 및 버그 감지를 가능하게 함으로써 자동 프로그래밍 분야를 크게 발전시켰습니다. GPT는 방대한 양의 자연어 텍스트로 사전 학습된 다음 질문 답변과 같은 특정 작업에 맞게 미세 조정된 딥 신경망입니다. 작업에 대한 자연어 설명이 주어지면 GPT는 원하는 작업을 수행하는 코드를 생성할 수 있으며, 이는 방대한 코드 코퍼스에서 모델을 미세 조정하여 달성됩니다. OpenAI의 Codex는 GPT 아키텍처를 기반으로 구축되어 ChatGPT에 통합된 언어 모델입니다. Chen et al.[13]은 Codex를 소개하고 소개, 인터뷰 및 경쟁 문제를 포함하여 163개의 코딩 문제 데이터 세트를 사용하여 평가했습니다. 평가는 많은 솔루션을 생성하고 적어도 하나가 단위 테스트를 통과했는지 확인하는 것으로 구성되었습니다. 따라서 문제당 100개의 샘플을 생성한 후, 그들의 솔루션은 문제의 77.5%를 해결할 수 있었습니다.그들은 성능에 접근하는 것이 아니라 효능(통과한 테스트 수)과 메모리 효율성을 기반으로 접근 방식을 평가했습니다.Imai[7], Nguyen과 Nadi[17]도 Codex 버전으로 실증적 연구를 수행했습니다.그들이 평가한 비기능적 요구 사항은 생산성, 코드 품질, 신뢰성, 정확성 및 이해성입니다.섹션 2에서 그들의 연구 결과를 설명합니다.3.1 목표 이러한 맥락에서 우리는 다음과 같은 질문을 하기로 했습니다. &quot;소프트웨어 엔지니어는 성능과 메모리 효율성 측면에서 AI 솔루션과 어떻게 비교됩니까?&quot; 이 질문을 탐구하기 위해 우리는 목표 활동으로 코딩 문제를 선택하고 숙련된 콘테스트 프로그래머가 제공한 솔루션과 ChatGPT가 제공한 솔루션을 비교했습니다.간단히 말해, 그림 1은 이 논문에서 조사하는 이론[21]을 보여줍니다.이 이론에 따르면 우리가 분리하여 측정하려는 변수는 세 가지 종류의 솔루션에서 달성한 성능과 메모리 효율성입니다.i) ChatGPT가 제공한 솔루션; ii) 경험자 콘테스트 프로그래머가 제공한 솔루션; iii) 초보 또는 비콘테스트 프로그래머가 제공한 솔루션.배우 프로그래머 ChatGPT 대 인간 프로그래머 기술은 솔루션을 생성합니다.경험자 콘테스트 프로그래머는 초보자 또는 비콘테스트 프로그래머보다 솔루션을 더 잘 생성합니다.ChatGPT 개선 개선 활동 프로그래밍 문제를 해석하고 코드 솔루션을 작성합니다.소프트웨어 시스템 코딩 문제 쉬움 보통 어려움 성능 사전 인쇄 메모리 효율성 그림 1: 이론[21]: ChatGPT는 더 높은 성능과 메모리 효율성으로 문제 해결 코딩 작업에서 프로그래머보다 우수한 성과를 보입니다.이러한 변수 간의 관계를 평가하기 위해 프로그래밍 인터뷰 준비를 위한 잘 확립된 온라인 플랫폼인 LeetCode를 사용하여 통제된 실험을 수행한 후 ChatGPT에서 제시한 솔루션을 소프트웨어 엔지니어가 이전에 개발한 솔루션과 병치했습니다.다음 하위 섹션에서는 연구 질문(RQx)과 이론의 명제를 설명합니다.이 실험을 수행하기 위해 새로운 코딩 문제가 있는 Leetcode의 가장 최근 콘테스트 중 하나를 선택했습니다¹. 그런 다음 이러한 문제를 ChatGPT의 프롬프트로 사용하여 코드를 생성했습니다. 그런 다음 ChatGPT에서 생성한 코드를 Leetcode에 업로드하여 성능 및 효율성 메트릭을 활용하여 기존 솔루션과 비교했습니다. Leetcode가 제출된 솔루션을 동일한 문제에 대한 모든 이전 솔루션과 비교한다는 점을 감안하여 프로그래머의 전문성을 전제로 이러한 메트릭에 대한 논의를 시작했습니다. 이를 위해 대회에서의 순위에 따라 구분된 42명의 프로그래머 그룹을 선택하고 Leetcode에서 이미 참가한 프로그래밍 대회 수에 따라 분류했습니다. 3.2 질문과 가설 문제 해결 코딩 분야에서 ChatGPT 솔루션의 결과는 다음에서 제공하는 솔루션과 어떻게 다릅니까? RQ1. ...경험이 풍부한 대회 프로그래머가 성능과 관련하여 쉬운, 보통 또는 어려운 코딩 문제를 해결하는 동안? RQ2. ...경험이 풍부한 대회 프로그래머가 메모리 효율성과 관련하여 쉬운, 보통 또는 어려운 코딩 문제를 해결하는 동안? RQ3. ...초보 콘테스트 프로그래머가 쉬운, 보통 또는 어려운 코딩 문제를 풀면서 메모리 효율성에 대해 어떻게 생각하십니까? RQ4. ...초보 콘테스트 프로그래머가 쉬운, 보통 또는 어려운 코딩 문제를 풀면서 메모리 효율성에 대해 어떻게 생각하십니까? 각 RQ는 다음에 설명되는 하나 이상의 가설을 기반으로 합니다. H - RQ1. • HO. ChatGPT는 숙련된 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 성능을 개선하지 않습니다. • HA. ChatGPT는 숙련된 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 성능을 개선합니다. &#39;콘테스트 설명은 https://leetcode.com/contest/biweekly-contest-103/에서 확인할 수 있습니다(2023년 5월 15일 접속) ChatGPT 대 인간 프로그래머 사전 인쇄 H - RQ2. • HO. ChatGPT는 숙련된 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 메모리 효율성을 개선하지 않습니다. • HA. ChatGPT는 숙련된 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 메모리 효율성을 개선합니다. H - RQ3. • HO. ChatGPT는 초보 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 성능을 개선하지 않습니다. • HA. ChatGPT는 초보 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 성능을 개선합니다. H - RQ4. • HO. ChatGPT는 초보 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 메모리 효율성을 개선하지 않습니다. • HA. ChatGPT는 초보 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 메모리 효율성을 개선합니다. 3.3 연구 대상: ChatGPT 개발자는 ChatGPT를 사용하여 그림 2와 같이 자연어 입력에서 코드를 생성할 수 있습니다. 시스템은 코드 외에도 시간 및 공간 복잡도 분석과 같이 생성된 코드에 대한 설명 및 평가를 제공할 수도 있습니다. NM 문자열을 반전하는 C++ 함수를 작성합니다. 모델: GPT-물론, `std::string 클래스를 사용하여 문자열을 반전하는 간단한 C++ 함수가 있습니다. cpp #include<string> std::string reverseString(const std::string&amp; str) { std::string reversedStr = str; int n = str.size();B for(int i = 0; i &lt; n / 2; i++) { std::swap(reversed Str[i], reversedStr[n - i 1]); } return reversedStr; } 응답 재생성 코드 복사 메시지 보내기. ChatGPT는 사람, 장소 또는 사실에 대한 부정확한 정보를 생성할 수 있습니다. ChatGPT 5월 12일 버전 그림 2: ChatGPT를 사용하여 코딩 문제를 해결하는 예. ChatGPT 대 인간 프로그래머 사전 인쇄 ChatGPT는 광범위한 프로그래밍 언어(Java, Kotlin, Python, C++, JavaScript, TypeScript, PHP, Go-lang, Ruby, Swift 등)에 대한 기능적 코드를 생성할 수 있지만, 우리는 C++에 중점을 두기로 했습니다. 이 결정은 C++가 가장 노련한 콘테스트 프로그래머가 주로 사용한다는 사실에 의해 내려졌습니다.우리는 ChatGPT-4를 사용하여 코드 솔루션을 생성했습니다.3.4 통제 실험 실험의 초기 단계에는 코딩 솔루션을 선택하고 구현할 플랫폼을 선택하는 것이 포함되었습니다.우리의 목표는 동일한 애플리케이션에 두 세트의 솔루션을 모두 제시하고 동일한 평가 프로세스를 사용하여 결과를 평가하는 것이었습니다.우리는 코딩 인터뷰 준비를 위한 온라인 플랫폼인 Leetcode를 선택했습니다.백만 명 이상의 사용자가 있으며 2,000개 이상의 코딩 문제와 솔루션을 제공하며, 일반적으로 대형 기술 회사에서 개발자의 기술을 평가하고 인터뷰를 수행하는 데 사용합니다.Leetcode는 성능(런타임 실행)과 메모리 사용량을 기준으로 솔루션을 비교합니다.우리는 Leetcode에서 가장 최근의 프로그래밍 콘테스트 중 하나를 선택했는데, 이 콘테스트는 쉬운 문제 1개, 보통 문제 2개, 어려운 문제 1개로 분류된 4개의 고유한 프로그래밍 과제를 제시했습니다.17,137명의 참가자 중 12,493명이 적어도 하나의 문제를 풀었습니다. 두 가지 문제를 푼 사람의 경우 그 수는 10,733으로 감소했고, 세 가지 문제를 푼 사람의 경우 7,133으로 더 감소했으며, 네 가지 문제 모두에서 단 700명으로 줄었습니다.그림 1에서 볼 수 있듯이, 우리가 분리하여 정량화하려는 요소 중 하나는 프로그래머의 기술 수준에 대한 솔루션의 성능과 메모리 효율성입니다.이를 위해 우리는 대회에서의 순위에 따라 프로그래머를 선택했으며, C++를 사용하고 가장 높은 순위에서 가장 낮은 순위까지 최소 세 가지 문제를 풀 수 있는 사람을 선택했습니다.LeetCode의 매개변수를 활용하여, 이들을 경험이 풍부한 대회 프로그래머와 초보 또는 비대회 프로그래머의 두 가지 범주로 나누었습니다.궁극적으로, 우리는 ChatGPT에서 생성한 솔루션의 성능과 메모리 효율성을 두 참가자 그룹이 제공한 솔루션과 병치했습니다.3.4.1 참가자 분석 그림 3은 LeetCode에서의 순위 수준에 따른 참가자의 분포 그래프를 보여줍니다.수준이 낮을수록 더 경험이 풍부한 프로그래머를 나타냅니다. 예를 들어, 선정된 프로그래머 중 8명은 LeetCode의 순위에 따르면 상위 1%에 속합니다.최고 평점 개발자(%)최고 평점(%)개발자 그림 3: LeetCode 글로벌 순위에 따른 참가자 분포.상위 30%의 프로그래머는 수많은 대회에 참여하여 문제 해결, 알고리즘적 사고 및 코딩 언어에 능숙한 숙련된 대회 프로그래머로 그룹화되었습니다.그들은 시간 압박 속에서도 문제를 빠르게 이해하고 해결하는 데 능숙합니다.나머지 참가자는 초보 또는 비대회 프로그래머로 분류되었으며, 이들의 전문성은 설계, 코딩, 테스트 및 디버깅과 같은 소프트웨어 개발 작업에 더 많이 있습니다.복잡한 문제를 해결할 수 있는 능력에도 불구하고 경쟁적 코딩에 덜 노출되어 대회 프로그래머의 속도와 전문적인 알고리즘 지식이 부족할 수 있습니다.ChatGPT 대 인간 프로그래머 사전 인쇄 3.4.2 실험: ChatGPT에서 제공한 솔루션 우리는 대회 내의 각 문제에 대한 솔루션을 공식화하기 위해 ChatGPT-4를 사용했습니다.². 원래 문제의 설명은 문제 해석을 단순화하기 위한 텍스트 수정 없이 프롬프트로 사용되었습니다.표 3.4.2는 각 솔루션의 성능 및 메모리 효율성과 함께 문제 목록을 요약한 것입니다.LeetCode 플랫폼에서 솔루션을 실행하면 런타임 및 메모리 효율성에 대한 데이터가 생성됩니다.또한 각 질문에 대한 글로벌 순위를 제공하여 성능 및 메모리 효율성 측면에서 이 솔루션보다 성능이 뛰어난 솔루션의 비율을 나타냅니다.이러한 결과는 LeetCode의 처리 수요에 따라 변동될 수 있습니다.시간 변화가 중요하지 않도록 동일한 솔루션을 여러 번 실행했습니다.또한 솔루션의 시간 및 공간 복잡도를 평가했습니다.흥미롭게도 특정 솔루션이 우수한 시간 복잡도 분석을 보여주었음에도 불구하고 다른 솔루션은 우수한 런타임 성능과 메모리 효율성을 보였습니다.이 예는 가장 간단한 문제에 대해 제공된 두 가지 솔루션에서 명확하게 입증됩니다.애플리케이션의 성능을 최적화하는 것은 알고리즘의 반복을 최소화하는 것뿐만 아니라 가장 효과적인 데이터 구조를 선택하는 것에 달려 있다는 것은 알려져 있습니다. 문제 이름 난이도 언어 작동한 솔루션 실패한 경우 테스트 사례 수 런타임 메모리(ms) (MB) 성능 메모리(비트) (비트) (%) (%) ID 시간 공간 복잡도 복잡도 LeetCode 제출 2656. Easy C++ 1/정확히 K개의 요소로 최대 합 2656.70.70.68.O(n log n + k^2 log n) O(n)최대 합 Easy C++ 2/71.21.12.O(n + k* log n) O(n)정확히 K개의 요소로 2657. 접두사 찾기 중간 C++ 1/80.78.97.O(n^3) O(n)두 배열의 공통 배열 2658. 최대 개수 중간 C++ 1/88.69.88.O((mn)²) O(mn)격자 안의 물고기 2659. 어렵게 만들기 C++505/배열 비어 있음 O(n^2) O(n)표 1: ChatGPT에서 제공한 코딩 솔루션의 결과 분석. 일부 문제의 경우 ChatGPT-4는 첫 번째 시도에서 작동하는 솔루션을 성공적으로 생성했습니다. 그러나 다른 문제의 경우 모든 테스트 사례를 통과할 수 있는 솔루션을 생성하려면 여러 번 반복해야 했습니다. 여러 소프트웨어 개발자도 Leetcode에서 수락하여 모든 테스트 사례를 통과하는 솔루션을 생성하기 전에 여러 솔루션을 제출해야 했다는 점이 주목할 만합니다. 가장 어려운 문제는 잘 풀리지 않았고, 생성된 50개가 넘는 솔루션(다양한 프로그래밍 언어로 작성) 중 어느 것도 모든 테스트 사례를 통과할 수 없었습니다. 이 경우 ChatGPT에서 생성한 가장 효과적인 솔루션은 514개 테스트 사례 중 505개를 통과했지만, 더 큰 입력에 대한 시간 제한 초과로 인해 실패했습니다. 이 질문의 미묘함은 배열에서 요소를 제거하는 알고리즘에 대한 텍스트 설명의 제안과 솔루션이 반드시 요소의 삭제나 이동을 필요로 하지 않고 대신 배열 길이에 초점을 맞춘다는 힌트 간의 역설에 있다고 가정합니다. 기본적으로 개발자의 솔루션은 문제 설명의 직접적인 해석과 다를 것으로 예상됩니다.Sobania et al.[22]은 다른 유사한 솔루션과 비교하여 ChatGPT의 코드 생성 기능을 평가하면서 자동화된 솔루션으로 해결할 수 없는 여러 문제는 인간 프로그래머가라도 확실하게 해결하기에는 너무 모호한 문제 설명으로 특징지어졌다고 언급했습니다.2제공된 프롬프트 및 코드 솔루션은 다음에서 사용할 수 있습니다.Google Drive 양식(2023년 5월 15일 액세스)ChatGPT 대 인간 프로그래머 사전 인쇄 3.5 실험 - 결과 표 3.4.2에 자세히 설명된 대로 ChatGPT-4에서 생성한 솔루션은 각 문제에 대한 기존 솔루션의 70.22%, 78.35%, 69.14%를 능가합니다.메모리 효율성 측면에서 ChatGPT-4에서 제공한 솔루션은 각각 68.69%, 97.47%, 88.14%를 능가합니다. 그러나 이 비교는 이전에 제공된 모든 솔루션을 포함하므로 이러한 자동화된 솔루션이 다양한 전문 지식 수준의 소프트웨어 엔지니어와 관련하여 어떻게 수행되는지에 대한 명확성이 부족합니다. 우리는 두 개발자 그룹이 제공한 솔루션을 실행하여 코드의 특정 런타임 및 메모리 효율성을 확인했습니다. 표 2는 개발자가 가장 복잡하지 않은 문제에 대해 생성한 솔루션에서 파생된 결과의 일부를 보여줍니다. 표 3, 4 및 5는 각각 쉬운 문제, 첫 번째 중간 문제 및 두 번째 중간 문제에 대해 선택된 참가자가 제공한 솔루션만을 고려하여 이를 해결합니다 ³. 그룹 개발자 글로벌 C++ 문제 수 순위 대회 TOR 런타임 메모리 위치(%) (ms) (MB) 해결됨 성능(비트) (%) 메모리(비트) (%) A0.70.98.29.A0.3770.93.68.A2,1.1770.30.29.B334,61785.1770.9.68.B351,78989.4570.21.13.B354,53590.1470.52.29.표 2: 선택된 참가자(그룹 A = 숙련자, B = 초보자)가 쉬운 문제에 대해 응답한 것에서 얻은 솔루션 인스턴스 선택. 변수 정도 N개의 표본 자유도 런타임 메모리 t 임계값(.99%) 런타임 런타임 런타임 메모리 메모리 메모리 최적 값 평균(n-1) 표준 편차 t 통계량 최적 값 평균 표준 프로그래머-2.54.16.-2.70.71.2.t 통계량 -1.경험자 경연대회-2.21.-1.70.72.3.-1.프로그래머 초보자 경연대회-2.54.8.-3.70.70.0.-1.프로그래머 ChatGPT-70.표 3: 쉬운 문제(2656. 정확히 K개의 요소로 최대 합계): 검정 통계량을 수행할 데이터 - 성능 및 메모리 효율성. 변수 정도 N개의 표본 자유도(n-1) 런타임 메모리 t 임계값(.99%) 런타임 런타임 런타임 프로그래머 숙련-2.최상의 값 평균 118.표준 편차 123.t통계 최상의 값 평균 -3.80.91.표준 24.메모리 메모리 메모리 t통계 -2.경연-2.83.67.-2.80.87.15.-1.프로그래머 초보자 경연-2.162.161.-2.81.95.31.-1.프로그래머 ChatGPT-80.표 4: 중간 문제(2657. 두 배열의 접두사 공통 배열 찾기): 테스트를 수행하기 위한 데이터 통계 성능 및 메모리 효율성.난이도가 높은 문제와 관련하여 ChatGPT와 초보자 경연 프로그래머 모두 해결하지 못한 채 남았습니다.숙련된 경연 프로그래머만이 이 코딩 문제에 대한 효과적인 솔루션을 제공하는 데 성공했습니다. ³ 각 참가자가 제공한 코드와 제출 링크는 다음에서 사용할 수 있습니다.Google Drive 양식(2023년 5월 15일 접속)ChatGPT 대 인간 프로그래머 A 사전 인쇄 학위 런타임 t 임계 런타임 런타임 메모리 런타임 메모리 N 메모리 변수 샘플 메모리 자유도 값(.99%) 최적 값 평균(n-1) 프로그래머-2.154.표준 편차 95.최상 t 통계량 평균 표준 t 통계량 값 -4.88.110.26.-4.경험자 경연 대회-2.138.102.-2.88.105.26.-2.프로그래머 초보자 경연 대회-2.178.81.-4.88.118.26.-4.프로그래머 ChatGPT-88.표 5: 중간 문제(2658. 그리드의 최대 물고기 수): 검정 통계를 수행하기 위한 데이터 - 성능 및 메모리 효율성. 3.5.1 가설 검정 이 부분에서는 3.2절에서 소개한 솔루션의 성능과 메모리 효율성 평가에 대한 가설을 조사합니다. 결과적으로, 우리는 3.5절의 세 표에 표시된 메트릭을 기반으로 Peck과 Devore[23]가 제시한 방법에 따라 통계 분석을 수행했습니다. 우리는 실험 결과를 경험이 풍부한 경연 대회 프로그래머의 결과와 초보 경연 대회 프로그래머의 결과라는 두 가지 범주로 나누었습니다. 그런 다음 각 그룹의 결과의 평균과 표준 편차를 계산했습니다. 이러한 통계적 측정값은 ChatGPT를 사용하여 얻은 결과와 병치되었습니다. 예를 들어, 첫 번째 가설(HRQ1)은 ChatGPT에서 생성된 솔루션이 전문 소프트웨어 엔지니어가 제안한 솔루션에 비해 애플리케이션 성능을 향상시켜 런타임이 단축된다고 가정합니다. 따라서 전문 소프트웨어 엔지니어의 솔루션의 평균 런타임은 쉬운 문제의 경우 47ms, 중간 문제의 경우 각각 53ms와 84ms를 기록한 ChatGPT 솔루션의 평균 런타임을 능가한다는 주장입니다. 영어: 0.01(100명 중 1명이 오류를 범할 확률)의 통계적 유의 수준[23]을 사용하여 다음과 같이 각 난이도 수준에 대한 검정 통계량(t-통계량)을 계산했습니다[23]. t-통계량: t = (x-가설값) (1) (뽕) t-통계량 이론에 따르면 t― 통계량 값이 음의 t-criticalvalue(임계값) 아래로 떨어지면 귀무 가설을 확실하게 기각할 수 있습니다[23]. 이는 선택된 참가자의 전체 샘플을 두 그룹으로 분류하지 않고 평가했다면 ChatGPT와 같은 자동화 솔루션이 일반적으로 프로그래머보다 성능이 우수할 수 있다는 증거를 찾을 수 있었음을 의미합니다. 세 가지 결과 표에서 볼 수 있듯이 프로그래머 전체를 고려할 때 모든 경우에서 runtimet 통계량 값은 음의 t-criticalvalue 값보다 낮습니다. 중간 수준 문제에서 memoryt – 통계량에도 마찬가지입니다. 그룹 3.6 토론 우리의 경험적 조사에서 우리는 다양한 경험 수준의 프로그래머가 제공한 솔루션의 성능과 메모리 효율성을 평가했고, 세 가지 대안 가설을 검증했으며 세 가지는 기각했습니다.수락: 1. 쉽고 중간 수준의 문제에서 ChatGPT는 초보 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 성능을 향상시킵니다.2. 중간 수준의 문제에서 ChatGPT는 경험이 풍부한 콘테스트 프로그래머와 초보 콘테스트 프로그래머가 제공한 솔루션과 비교하여 코딩 솔루션의 메모리 효율성을 향상시킵니다.기각: 1. ChatGPT는 경험이 풍부한 콘테스트 프로그래머가 제공한 솔루션과 비교하여 쉽고 중간 또는 어려운 수준의 문제에 대한 코딩 솔루션의 성능을 향상시킵니다.2. 쉽고 어려운 수준의 코딩 문제의 경우 ChatGPT는 초보자 또는 경험이 풍부한 콘테스트 프로그래머가 제공한 솔루션과 비교하여 뛰어난 메모리 효율성을 보여줍니다.ChatGPT 대 인간 프로그래머 사전 인쇄본 이러한 결과는 ChatGPT와 같은 자동화된 솔루션이 특정 소프트웨어 엔지니어링 작업에서 소프트웨어 엔지니어보다 성능이 우수할 수 있음을 시사합니다. 구체적으로, ChatGPT는 쉬운 중간 수준의 문제를 해결하는 데 있어 초보 콘테스트 프로그래머보다 우수한 성능을 보였고 중간 수준의 문제 중 하나에서 더 나은 메모리 효율성도 보였습니다. 그러나 ChatGPT가 숙련된 콘테스트 프로그래머가 제공한 솔루션의 성능을 능가한다는 것을 주장할 만한 증거는 찾지 못했습니다. 소프트웨어 개발 작업 자동화에 대한 상당한 연구 관심을 감안할 때 이러한 통찰력은 주목할 만합니다. 요약하자면, 우리 연구는 소프트웨어 엔지니어의 성과와 AI 기반 솔루션 간에 미묘한 관계가 있음을 시사합니다. 특정 시나리오에서는 소프트웨어 엔지니어가 뛰어나지만 다른 시나리오에서는 AI가 더 우수한 것으로 입증되었습니다. 이는 보다 효과적인 협업 작업과 작업 할당 프로세스를 용이하게 하기 위해 인간과 자동화된 접근 방식의 고유한 강점을 이해하는 것의 중요성을 강조합니다[24]. 또한 이 연구 결과는 Melo 등이 제시한 관점에 따라 적응 가능한 수준의 자동화를 갖춘 AI 시스템이 필요함을 강조합니다[25]. 소프트웨어 엔지니어링 맥락에서 이는 개발자의 경험과 해당 작업의 품질 요구 사항에 따라 AI 자동화 수준을 조정해야 함을 시사합니다. 3.7 유효성에 대한 위협 ChatGPT에서 사용하는 정확한 교육 및 테스트 데이터는 공개되지 않은 상태로 유지되므로 쿼리의 정확한 솔루션이 데이터 내에 이미 있는지 확인할 수 없습니다. 결과적으로 해당 도구를 교육하는 데 사용된 특정 코딩 과제는 확인되지 않은 상태로 유지됩니다. 새로운 문제가 있는 최근 LeetCode 경연 대회를 선택했지만 알고리즘을 교육하는 데 사용된 문제와 유사하거나 동일한 문제를 테스트하지 않았다고 보장할 수 없습니다. 따라서 해당 도구가 새로운 솔루션을 생성하지 않고 특정 문제에 대한 이전에 저장된 솔루션을 검색할 수 있습니다. 게다가 소프트웨어 엔지니어가 이전에 자동화된 시스템을 활용하여 적절한 인정 없이 LeetCode에 질문을 제출했을 가능성이 있습니다. 따라서 비교가 개발자가 제공한 솔루션과만 이루어졌다고 단언할 수 없습니다. 예를 들어, Golzadeh 등은 GitHub에서 봇의 기여를 인정하지 않음에도 불구하고 봇이 GitHub에서 가장 활동적인 기여자 중 하나로 정기적으로 등장한다는 증거를 제시했습니다[8]. 이 문제를 완화하기 위해 참여자 선택을 구현했습니다. 4
--- CONCLUSION ---
및 향후 연구 여러 연구자들이 소프트웨어 엔지니어링 작업을 자동화하기 위해 AI 시스템을 사용할 것을 제안했습니다. 그러나 이러한 접근 방식 대부분은 AI 기반 절차가 현재 표준 및 수동 관행보다 성공률이 더 높은지 여부를 묻는 데 노력을 기울이지 않습니다. 이 잠재적인 조사 라인에서 관련 질문은 &quot;소프트웨어 엔지니어가 자동화 시스템보다 특정 개발 작업을 더 잘 해결할 수 있을까?&quot;입니다. 실제로 엔지니어 또는 AI 절차가 어떤 작업을 더 잘 수행하는지 평가하여 보다 효과적으로 함께 작업하고 SE 작업을 지원하기 위한 새로운 인간 참여형 AI 접근 방식에 대한 더 많은 통찰력을 제공하는 것이 기본입니다. AI 기반 계산이 생산성을 향상시키고 소프트웨어 개발에서 소프트웨어 엔지니어를 대체할 수 있다는 추측이 있지만 이 주장을 뒷받침하는 현재 실증적 증거는 부족합니다. 실제로 제한된 수의 논문에서 소프트웨어 엔지니어링에서 머신 러닝 기술을 적용하는 것에 대한 실증적 조사를 제공합니다. 이 논문은 ChatGPT와 같은 자동화된 전략을 사용하여 소프트웨어 엔지니어링에서 작업을 자동화하는 것, 특히 코딩 문제를 해결하는 것을 조사하는 실증적 연구를 소개합니다. 게다가 실험 연구에 내재되어 있는 것처럼, 신중한 설계와 실행에도 불구하고 특정 요인은 실험적 타당성에 위협이 될 수 있습니다. 그러한 잠재적 위협 중 하나는 ChatGPT에서 사용하는 정확한 교육 및 테스트 데이터입니다. 저희의 실증적 연구는 ChatGPT와 같은 자동화 시스템이 특정한 경우에 특정 작업에서 초보 소프트웨어 엔지니어의 성과를 능가할 수 있다는 것을 발견했습니다. 이러한 우월성은 특히 쉬운 중간 수준의 문제를 해결하는 데 특히 두드러졌는데, ChatGPT의 성과는 초보 콘테스트 프로그래머의 성과를 지속적으로 능가했습니다. 게다가 AI 기반 솔루션은 중간 수준의 문제에 대해 향상된 메모리 효율성을 보여주었습니다. 반면에 ChatGPT가 솔루션 성능 측면에서 숙련된 콘테스트 프로그래머를 능가할 수 있다는 것을 시사하는 실질적인 증거는 찾지 못했습니다. 본질적으로 저희의 연구는 소프트웨어 엔지니어링 작업에서 인간과 AI 성과 간의 역동적인 상호 작용을 보여주며, 이는 다양한 작업 할당 프로세스의 필요성을 강조합니다. 이는 개발자의 전문성과 작업 품질 요구 사항에 따라 AI 지원을 미세 조정하는 협력적 접근 방식을 장려합니다. 이 실증적 조사는 코딩에서 문제 해결의 영역을 넘어 소프트웨어 엔지니어링 작업에서 자동화의 잠재력을 탐구해야 합니다. 제안된 실험을 확장하기 위한 향후 작업에는 다음이 포함됩니다.(i) 설계, 유지 관리, 테스트 및 프로젝트 관리와 같은 다른 SE 작업을 평가하기 위한 추가 경험적 연구 수행;(ii) 비지도 머신 러닝 알고리즘과 같은 다른 AI 접근 방식 실험;(iii) 다른 ChatGPT 대 인간 프로그래머 A PREPRINT 기준을 사용하여 작업 실행을 평가하고 다른 정성적 또는 정량적 방법론을 다룹니다.조사할 수 있는 가능한 작업((i) 참조)에는 테스트 작업(예: 개발자가 식별한 오류의 수, 유형 및 난이도 수준 비교), 작업 설계(즉, 시스템 사용성 액세스), 유지 관리 작업(즉, 지속적인 성능 액세스) 및 프로젝트 관리 작업(즉, 작업 할당 프로세스에서 개발자의 만족도 수준 평가)이 포함됩니다.감사의 말 이 작업은 캐나다 자연과학 및 공학 연구 위원회(NSERC)와 커뮤니티 매핑 센터(COMAP)의 지원을 받았습니다.참고문헌 [1] OpenAI. Gpt-4 기술 보고서. https://doi.org/10.48550/arXiv.2303.08774, 2023. [2] Tyna Eloundou, Sam Manning, Pamela Mishkin, Daniel Rock. Gpts are gpts: An early look at the labour market impact potential of large language models, 2023. [3] Jules White, Sam Hays, Quchen Fu, Jesse Spencer-Smith, Douglas C Schmidt. Chatgpt 프롬프트 패턴은 코드 품질, 리팩토링, 요구 사항 도출 및 소프트웨어 설계를 개선합니다. https://doi.org/10.48550/arXiv.2303.07839, 2023. [4] Dominik Sobania, Martin Briesch, Carol Hanna, Justyna Petke. chatgpt의 자동 버그 수정 성능 분석. https://doi.org/10.48550/ARXIV.2301.08653, 2023. [5] Federica Sarro. 최신 소프트웨어 시스템 속성의 자동 최적화. ACM/SPEC 성능 엔지니어링 국제 컨퍼런스 회의록, 3-4페이지, 2023. [6] Glaucia Melo, Luis Fernando Lins, Paulo Alencar, Donald Cowan. 상황에 맞는 대화형 에이전트 기반 소프트웨어 개발 지원. 소프트웨어 엔지니어링 국제 컨퍼런스, 2023. [7] Saki Imai. github copilot이 인간 쌍 프로그래밍을 대체할 수 있을까? 실증적 연구. ACM/IEEE 44th International Conference on Software Engineering: Companion Proceedings의 회의록, 319-321페이지, 2022. [8] Mehdi Golzadeh, Tom Mens, Alexandre Decan, Eleni Constantinou, Natarajan Chidambaram. 협업 소프트웨어 개발에서 봇 활동 인식. IEEE 소프트웨어, 39(5):56–61, 2022. [9] Emily M Bender, Timnit Gebru, Angelina McMillan-Major, Shmargaret Shmitchell. 확률적 앵무새의 위험에 관하여: 언어 모델이 너무 클 수 있을까? 2021 ACM 공정성, 책임성 및 투명성 컨퍼런스 회의록, 610-623페이지, 2021. [10] Stefanos Georgiou, Maria Kechagia, Tushar Sharma, Federica Sarro 및 Ying Zou. Green ai: 딥 러닝 프레임워크의 비용이 다를까요? 44회 국제 소프트웨어 엔지니어링 컨퍼런스 회의록, 1082-1094페이지, 2022. [11] Hammond Pearce, Baleegh Ahmad, Benjamin Tan, Brendan Dolan-Gavitt 및 Ramesh Karri. 키보드에서 잠들었나요? github copilot의 코드 기여에 대한 보안 평가. 2022 IEEE 보안 및 개인 정보 보호 심포지엄(SP), 754-768페이지. IEEE, 2022. [12] Ninareh Mehrabi, Fred Morstatter, Nripsuta Saxena, Kristina Lerman 및 Aram Galstyan. 머신 러닝의 편향 및 공정성에 대한 설문 조사. ACM Comput. Surv., 54(6), 2021년 7월. [13] Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de Oliveira Pinto, Jared Kaplan, Harri Edwards, Yuri Burda, Nicholas Joseph, Greg Brockman 등. 코드에서 학습된 대규모 언어 모델 평가. arXiv 사전 인쇄본 arXiv:2107.03374, 2021. [14] Jeevana Priya Inala, Chenglong Wang, Mei Yang, Andres Codas, Mark Encarnación, Shuvendu Lahiri, Madanlal Musuvathi 및 Jianfeng Gao. 오류 인식 신경 코드 순위 지정기. 신경 정보 처리 시스템의 발전, 35:13419-13432, 2022. [15] Nathalia Nascimento, Paulo Alencar, Carlos Lucena, Donald Cowan. 소프트웨어 엔지니어와 머신 러닝 알고리즘 간의 인간 참여 협업을 향해. 2018년 IEEE 빅데이터 국제 컨퍼런스(빅데이터), 3534-3540페이지. IEEE, 2018. [16] Steve Easterbrook, Janice Singer, Margaret-Anne Storey, Daniela Damian. 소프트웨어 엔지니어링 연구를 위한 경험적 방법 선택. 고급 경험적 소프트웨어 엔지니어링 가이드, 285-311페이지, 2008. ChatGPT 대 인간 프로그래머 사전 인쇄본 [17] Nhan Nguyen과 Sarah Nadi. github 조종사의 코드 제안에 대한 경험적 평가. 19th International Conference on Mining Software Repositories의 회의록, 1-5페이지, 2022. [18] Yujia Li, David Choi, Junyoung Chung, Nate Kushman, Julian Schrittwieser, Rémi Leblond, Tom Eccles, James Keeling, Felix Gimeno, Agustin Dal Lago, et al. alphacode를 사용한 경쟁 수준 코드 생성. Science, 378(6624):1092-1097, 2022. [19] Sila Lertbanjongngam, Bodin Chinthanet, Takashi Ishio, Raula Gaikovina Kula, Pattara Leelaprute, Bundit Manaskasemsak, Arnon Rungsawang, Kenichi Matsumoto. 경쟁 프로그래밍 ai에 대한 실증적 평가: alphacode 사례 연구. 2022년 IEEE 16th International Workshop on Software Clones(IWSC), 10-15페이지. IEEE, 2022. [20] F Brooks 및 HJ Kugler. 만병통치약은 없다. 1987년 4월. [21] Dag IK Sjøberg, Tore Dybå, Bente CD Anda 및 Jo E Hannay. 소프트웨어 엔지니어링에서 이론 구축. 고급 경험적 소프트웨어 엔지니어링 가이드, 312-336페이지, 2008. [22] Dominik Sobania, Martin Briesch 및 Franz Rothlauf. 프로그래밍 조종사 선택: github 조종사와 유전 프로그래밍의 프로그램 합성 성능 비교. 유전 및 진화 계산 컨퍼런스 회의록, 1019-1027페이지, 2022. [23] Roxy Peck 및 Jay Devore. 통계: 데이터 탐색 및 분석. Nelson Education, 2011. [24] Nathalia Nascimento, Paulo Alencar, Donald Cowan. 인간 참여형 빅데이터 소프트웨어 개발 프로젝트를 지원하는 접근 방식. 2021년 IEEE 빅데이터 국제 컨퍼런스(빅데이터), 2319-2326페이지. IEEE, 2021. [25] Glaucia Melo, Nathalia Nascimento, Paulo Alencar, Donald Cowan. 인간-기계 협업에서 자동화 수준 이해. 2022년 IEEE 빅데이터 국제 컨퍼런스(빅데이터), 3952-3958페이지. IEEE, 2022.
