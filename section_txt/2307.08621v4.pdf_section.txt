--- ABSTRACT ---
In this work, we propose Retentive Network (RETNET) as a foundation architecture for large language models, simultaneously achieving training parallelism, low-cost inference, and good performance. We theoretically derive the connection between recurrence and attention. Then we propose the retention mechanism for sequence modeling, which supports three computation paradigms, i.e., parallel, recurrent, and chunkwise recurrent. Specifically, the parallel representation allows for training parallelism. The recurrent representation enables low-cost O(1) inference, which improves decoding throughput, latency, and GPU memory without sacrificing performance. The chunkwise recurrent representation facilitates efficient long-sequence modeling with linear complexity, where each chunk is encoded parallelly while recurrently summarizing the chunks. Experimental results on language modeling show that RETNET achieves favorable scaling results, parallel training, low-cost deployment, and efficient inference. The intriguing properties make RETNET a strong successor to Transformer for large language models. Code will be available at https: //aka.ms/retnet. Inference Cost Scaling Curve 8.4X 40 300 300[= 20 3.4X 150 150 ia = | 15.6X 0 0 0 = 1 3)GPU Memory| Throughputt Latency| . (GB) (wps) (ms) Model Size (B) Transformer RetNet Mil Figure 1: Retentive network (RetNet) achieves low-cost inference (i.e., GPU memory, throughput, and latency), training parallelism, and favorable scaling curves compared with Transformer. Results of inference cost are reported with 8k as input length. Figure 6 shows more results on different sequence lengths. * Equal contribution. © Corresponding author. --- --(4 6 The only way to discover the limits of the possible is to go beyond them into the impossible. 9Arthur C. Clarke 1
--- METHOD ---
’s popularity. The second strand returns to recurrent models for efficient inference while sacrificing training parallelism. As a remedy, element-wise operators [PAA* 23] are used for acceleration, however, representation capacity and performance are harmed. The third line of research explores replacing attention with other mechanisms, such as $4 [GGR21], and its variants [DFS*22, PMN*23]. None of the previous work can break through the impossible triangle, resulting in no clear winner compared with Transformers. In this work, we propose retentive networks (RetNet), achieving low-cost inference, efficient longsequence modeling, Transformer-comparable performance, and parallel model training simultaneously. Specifically, we introduce a multi-scale retention mechanism to substitute multi-head attention, which has three computation paradigms, i.e., parallel, recurrent, and chunkwise recurrent representations. First, the parallel representation empowers training parallelism to utilize GPU devices fully. Second, the recurrent representation enables efficient O(1) inference in terms of memory and computation. The deployment cost and latency can be significantly reduced. Moreover, the implementation is greatly simplified without key-value cache tricks. Third, the chunkwise recurrent representation can perform efficient long-sequence modeling. We parallelly encode each local block for computation speed while recurrently encoding the global blocks to save GPU memory. We conduct extensive
--- EXPERIMENT ---
al results on language modeling show that RETNET achieves favorable scaling results, parallel training, low-cost deployment, and efficient inference. The intriguing properties make RETNET a strong successor to Transformer for large language models. Code will be available at https: //aka.ms/retnet. Inference Cost Scaling Curve 8.4X 40 300 300[= 20 3.4X 150 150 ia = | 15.6X 0 0 0 = 1 3)GPU Memory| Throughputt Latency| . (GB) (wps) (ms) Model Size (B) Transformer RetNet Mil Figure 1: Retentive network (RetNet) achieves low-cost inference (i.e., GPU memory, throughput, and latency), training parallelism, and favorable scaling curves compared with Transformer. Results of inference cost are reported with 8k as input length. Figure 6 shows more results on different sequence lengths. * Equal contribution. © Corresponding author. --- --(4 6 The only way to discover the limits of the possible is to go beyond them into the impossible. 9Arthur C. Clarke 1 Introduction Transformer [VSP*17] has become the de Low-Cost facto architecture for large language mod- Inference els [BMR* 20], which was initially proposed to overcome the sequential training issue of recurrent models [HS97]. However, training parallelism of Transformers is at the cost of inefficient inference, because of the O(N) complexity per step and memory-bound key-value cache [Shal9], which renders Transformers unfriendly to deployment. The growing sequence length increases GPU memory consumption as well as latency and reduces inference speed. P &. ics) Numerous efforts have continued to develop the % o Transformer ¢ next-generation architecture, aiming at retain- a e& ing training parallelism and competitive performance as Transformers while having efficient Figure 2: RetNet makes the “impossible triangle” O(1) inference. It is challenging to achieve the possible, which achieves training parallelism, good above goals simultaneously, ie., the so-called performance, and low inference cost simultane“impossible triangle” as shown in Figure 2. ously. There have been three main strands of research. First, linearized attention [K VPF20] approximates standard attention scores exp(q - k) with kernels ¢(q) - ¢(k), so that autoregressive inference can be rewritten in a recurrent form. However, the modeling capability and performance are worse than Transformers, which hinders the method’s popularity. The second strand returns to recurrent models for efficient inference while sacrificing training parallelism. As a remedy, element-wise operators [PAA* 23] are used for acceleration, however, representation capacity and performance are harmed. The third line of research explores replacing attention with other mechanisms, such as $4 [GGR21], and its variants [DFS*22, PMN*23]. None of the previous work can break through the impossible triangle, resulting in no clear winner compared with Transformers. In this work, we propose retentive networks (RetNet), achieving low-cost inference, efficient longsequence modeling, Transformer-comparable performance, and parallel model training simultaneously. Specifically, we introduce a multi-scale retention mechanism to substitute multi-head attention, which has three computation paradigms, i.e., parallel, recurrent, and chunkwise recurrent representations. First, the parallel representation empowers training parallelism to utilize GPU devices fully. Second, the recurrent representation enables efficient O(1) inference in terms of memory and computation. The deployment cost and latency can be significantly reduced. Moreover, the implementation is greatly simplified without key-value cache tricks. Third, the chunkwise recurrent representation can perform efficient long-sequence modeling. We parallelly encode each local block for computation speed while recurrently encoding the global blocks to save GPU memory. We conduct extensive experiments to compare RetNet with Transformer and its variants. Experimental results on language modeling show that RetNet is consistently competitive in terms of both scaling curves and in-context learning. Moreover, the inference cost of RetNet is length-invariant. For a 7B model and 8k sequence length, RetNet decodes 8.4 faster and saves 70% of memory than Transformers with key-value caches. During training, RetNet also achieves 25-50% memory saving and 7x acceleration than standard Transformer and an advantage towards highly-optimized FlashAttention [DFE* 22]. Besides, RetNet’s inference latency is insensitive to batch size, allowing enormous throughput. The intriguing properties make RetNet a strong successor to Transformer for large language models. --- --2 Retentive Networks Retentive network (RetNet) is stacked with L identical blocks, which follows a similar layout (i.e., residual connection, and pre-LayerNorm) as in Transformer [VSP* 17]. Each RetNet block contains two modules: a multi-scale retention (MSR) module, and a feed-forward network (FFN) module. We introduce the MSR module in the following sections. Given an input sequence © = 11 +++ Zo, RetNet encodes the sequence in an autoregressive way. The input vectors {a}, is first packed into X° = [wi,--: + L)x|] € RitlX4moict, where dmodet is hidden dimension. Then we compute contextualized vector representations X! = RetNet;(X'~'),1 € [1, L]. 2.1 Retention In this section, we introduce the retention mechanism that has a dual form of recurrence and parallelism. So we can train the models in a parallel way while recurrently conducting inference. Given input X € R!*!*4moe1, we project it to one-dimensional function v(n) = X,, - wy. Consider a sequence modeling problem that maps v(n) ++ o(n) through states s,,. Let up, on denote u(n), o(n) for simplicity. We formulate the mapping in a recurrent manner: Sn = A8n-1 + KT Un, AeR™4 K, eR “ (1) On = Qn8n = D> QnA” KT Um: Qn €R*m=where we map v,, to the state vector s,,, and then implement a linear transform to encode sequence information recurrently. Next, we make the projection Q,,, K, content-aware: Q=XWe, K=XWrK (2) where Wo, Wx € R27“ are learnable matrices. We diagonalize the matrix A = A(ye'®)A~!, where 7,9 € R¢. Then we obtain A"~™” = A(qe!®)"—™ A-1. By absorbing A into Wg and Wj, we can rewrite Equation (1) as: n On = D> Qn(yel®)"- "KT, 0m m== > (Qn (ye"*)")(Kim (yet?) -") 0m m=(3) where Qn, (ye®)”, Km (yei#)-™ is known as xPos [SDP* 22], i-e., a relative position embedding proposed for Transformer. We further simplify 7 as a scalar, Equation (3) becomes: n On = YP ™QneiM)(K ner?) 4) m=where * is the conjugate transpose. The formulation is easily parallelizable within training instances. In summary, we start with recurrent modeling as shown in Equation (1), and then derive its parallel formulation in Equation (4). We consider the original mapping v(n) ++ o0(n) as vectors and obtain the retention mechanism as follows. The Parallel Representation of Retention As shown in Figure 3a, the retention layer is defined as: Q=(XWe) 00, K=(XWK)O0, V=XWy , yn an >m 0, =e”, Pam = 4, oon (5) Retention(X) = (QK™ © D)V where © is the complex conjugate of ©, and D € R'*!*!*! combines causal masking and exponential decay along relative distance as one matrix. Similar to self-attention, the parallel representation enables us to train the models with GPUs efficiently. --- --a) i GN Sno or Sn t Recurrent t J (QK'© DV State pt IB On t t Output —_t—, Vn Kn Qn Q K Vv L—— a Xn x Input (a) Parallel representation. (b) Recurrent representation. Figure 3: Dual form of RetNet. “GN” is short for GroupNorm. The Recurrent Representation of Retention As shown in Figure 3b, the proposed mechanism can also be written as recurrent neural networks (RNNs), which is favorable for inference. For the n-th timestep, we recurrently obtain the output as: Sn = YSn-1+ KTVn Retention(X,) =QnSn, n=1,---,|2| © where Q, K, V,7 are the same as in Equation (5). The Chunkwise Recurrent Representation of Retention A hybrid form of parallel representation and recurrent representation is available to accelerate training, especially for long sequences. We divide the input sequences into chunks. Within each chunk, we follow the parallel representation (Equation (5)) to conduct computation. In contrast, cross-chunk information is passed following the recurrent representation (Equation (6)). Specifically, let B denote the chunk length. We compute the retention output of the i-th chunk via: Qi) = QBi:Bisi), Ajj = Keir), Vig = Vaiss) R= KV oQ+V Ria, Gy =" : ; (7) Retention(Xj,)) = (Qukq, fo) D)Vjay +4 (Qi Ri-1) of &y= yitt ae Inner-Chunk Cross-Chunk where [i] indicates the i-th chunk, i.e., 7p = [e(-1)B41,°°* » TiB) 2.2. Gated Multi-Scale Retention We use h = dmoiei/d retention heads in each layer, where d is the head dimension. The heads use different parameter matrices Wg,Wx,Wy € IR?**4, Moreover, multi-scale retention (MSR) assigns different 7 for each head. For simplicity, we set 7 identical among different layers and keep them fixed. In addition, we add a swish gate [HG16, RZL17] to increase the non-linearity of retention layers. Formally, given input X, we define the layer as: y= 1 — Q-S-arange(0.h) © Rh head; = Retention(X, ¥;) Y = GroupNorm, (Concat(head;, +++ ,head;,)) MSR(X) = (swish(XWe) © Y)Wo (8) where Wg, Wo € Rim 4noiet are learnable parameters, and GroupNorm [WH18] normalizes the output of each head, following SubLN proposed in [SPP* 19]. Notice that the heads use multiple scales, which results in different variance statistics. So we normalize the head outputs separately. The pseudocode of retention is summarized in Figure 4. --- --def ParallelRetention( def RecurrentRetention( q, # bsz * num_head * len * qk_dim q, k, v, # bsz * num_head * len * qkv_dim k, # bsz * num_head * len * qk_dim past_kv, # bsz * num_head * qk_dim * v_dim v, # bsz * num_head * len * v_dim decay # num_head * 1 *decay_mask # num_head * len * len ): ): current_kv = decay * past_kv + k.unsqueeze retention = q @ k.transpose(-1, -2) (-1) * v.unsqueeze (-2) retention = retention * decay_mask output = torch.sum(q.unsqueeze(-1) * output = retention @ v current_kv, dim=-2) output = group_norm(output) output = group_norm(output) return output return output, current_kv def ChunkwiseRetention( q, k, v, # bsz * num_head * chunk_size * qkv_dim past_kv, # bsz * num_head * qk_dim * v_dim decay_mask, # num_head * chunk_size * chunk_size chunk_decay, # num_head * 1 *inner_decay, # num_head * chunk_size d: retention = q @ k.transpose(-1, -2) retention = retention * decay_mask inner_retention = retention @ v cross_retention = (q @ past_kv) * inner_decay retention = inner_retention + cross_retention output = group_norm(retention) current_kv = chunk_decay * past_kv + k.transpose(-1, -2) @v return output, current_kv Figure 4: Pseudocode for the three computation paradigms of retention. Retention Score Normalization We utilize the scale-invariant nature of GroupNorm to improve the numerical precision of retention layers. Specifically, multiplying a scalar value within GroupNorm does not affect outputs and backward gradients, i.e., GroupNorm(a * head;) = GroupNorm(head;). We implement three normalization factors in Equation (5). First, we normalize QKT as @K"/Vd. Second, we replace D with Dam = Dnm/,/S*_, Dri. Third, let R denote the retention scores R = QKT © D, we normalize it as Rim = Rnm/max(| O21 Rnil.1). Then the retention output becomes Retention(X) = RV. The above tricks do not affect the final results while stabilizing the numerical flow of both forward and backward passes, because of the scale-invariant property. 2.3. Overall Architecture of Retention Networks For an L-layer retention network, we stack multi-scale retention (MSR) and feed-forward network (FEN) to build the model. Formally, the input sequence {x,}!"" is transformed to vectors by a word embedding layer. We use the packed embeddings X° = [a1,--- , Lai] € Rl#!*¢noit ag the input and compute the model output X": Y' = MSR(LN(X')) + X! (9) X'+! — FFN(LN(Y!)) + Y! where LN(-) is LayerNorm [BKH16]. The FFN part is computed as FFN(X) = gelu(XW,)Wo, where W,, W2 are parameter matrices. Training We use the parallel (Equation (5)) and chunkwise recurrent (Equation (7)) representations during the training process. The parallelization within sequences or chunks efficiently utilizes GPUs to accelerate computation. More favorably, chunkwise recurrence is especially useful for long-sequence training, which is efficient in terms of both FLOPs and memory consumption. --- --Architectures Panne a Inference Cost Memon, Complexity Performance Transformer v O(N) O(N?) vw Linear Transformer Vv O(1) O(N) x Recurrent NN x O(1) O(N) x RWKV x O(1) O(N) v H3/S4 Vv o(1) O(N log N) Vv Hyena Vv O(N) O(N log N) Vv RetNet Vv oO(1) O(N) VW Table 1: Model comparison from various perspectives. RetNet achieves training parallelization, constant inference cost, linear long-sequence memory complexity, and good performance. Inference The recurrent representation (Equation (6)) is employed during the inference, which nicely fits autoregressive decoding. The O(1) complexity reduces memory and inference latency while achieving equivalent results. 2.4 Relation to and Differences from Previous Methods Table | compares RetNet with previous methods from various perspectives. The comparison results echo the “impossible triangle” presented in Figure 2. Moreover, RetNet has linear memory complexity for long sequences due to the chunkwise recurrent representation. We also summarize the comparisons with specific methods as follows. Transformer The parallel representation of retention shares similar spirits as Transformers [VSP+17]. The most related Transformer variant is Lex Transformer [SDP* 22] which implements xPos as position embeddings. As described in Equation (3), the derivation of retention aligns with xPos. In comparison with attention, retention removes softmax and enables recurrent formulation, which significantly benefits inference. $4 Unlike Equation (2), if Q,, and K’, are content-unaware, the formulation can be degenerated to S4 [GGR21], where O = (QKT, QAKT,.., QAI*I-! KT) & V. Linear Attention The variants typically use various kernels $(4:)¢(3)/S7!*!, 4(q:)4(kn) to replace the softmax function. However, linear attention struggles to effectively encode position information, rendering the models less performant. Besides, we reexamine sequence modeling from scratch, rather than aiming at approximating softmax. AFT/RWKV Attention Free Transformer (AFT) simplifies dot-product attention to element-wise operations and moves softmax to key vectors. RWKV replaces AFT’s position embeddings with exponential decay and runs the models recurrently for training and inference. In comparison, retention preserves high-dimensional states to encode sequence information, which contributes to expressive ability and better performance. xPos/RoPE Compared with relative position embedding methods proposed for Transformers, Equation (3) presents a similar formulation as xPos [SDP* 22] and RoPE [SLP* 21]. Sub-LayerNorm As shown in Equation (8), the retention layer uses Sub-LayerNorm [WMH* 22] to normalize outputs. Because the multi-scale modeling leads to different variances for the heads, we replace the original LayerNorm with GroupNorm. 3 Experiments We conduct experiments on language modeling to evaluate RetNet. We evaluate the proposed architecture with various benchmarks, i.e., language modeling performance, and zero-/few-shot learning on downstream tasks. Moreover, for training and inference, we compare speed, memory consumption, and latency. --- --Size HiddenDim. #Layers BatchSize #Tokens Learning Rate 1.3B 2048 24 4M 100B 6 x 10-2.7B 2560 32 4M 100B 3x 10-6.7B 4096 32 4M 100B 3x 10-Table 2: Sizes, and learning hyper-parameters of the models in language modeling experiments. 15.a614.$ 13.12.==e== RetNet —= Transformer 1.3B 2.7B 6.7B Model Size Figure 5: Perplexity decreases along with scaling up the model size. We empirically observe that RetNet tends to outperform Transformer when the model size is larger than 2B. 3.1 Setup Parameter Allocation We re-allocate the parameters in MSR and FEN for fair comparisons. Let d denote dmodei for simplicity here. In Transformers, there are about 4d? parameters in self-attention where Wo, Wx, Wy, Wo € R®*“, and 8d? parameters in FFN where the intermediate dimension is 4d. In comparison, RetNet has 8d? parameters in retention, where Wg, Wx € RY“4,We, Wy € R24, Wo € R?4*4, Notice that the head dimension of V is twice Q, K. The widened dimension is projected back to d by Wo. In order to keep the parameter number the same as Transformer, the FEN intermediate dimension in RetNet is 2d. Meanwhile, we set the head dimension to 256 in our experiments, i.e., 256 for queries and keys, and 512 for values. For fair comparison, we keepidentical among different model sizes, where y = 1 — elispace(log */s2,10g 7/512.) © RR” instead of the default value in Equation (8). Language Model Training As shown in Table 2, we train language models with various sizes (i.e., 1.3B, 2.7B, and 6.7B) from scratch. The training corpus is a curated compilation of The Pile [GBB* 20], C4 [DMI* 21], and The Stack [KLBA* 22]. We append the <bos> token to indicate the start of a sequence*. The training batch size is 4M tokens with 2048 maximal length. We train the models with 100B tokens, i.e., 25k steps. We use the AdamW [LH19] optimizer with B, = 0.9, Bz = 0.98, and weight decay is set to 0.05. The number of warmup steps is 375 with linear learning rate decay. The parameters are initialized following DeepNet [WMD* 22] to guarantee training stability. The implementation is based on TorchScale [MWH1 22]. We train the models with 512 AMD MI200 GPUs. 3.2 Comparisons with Transformer Language Modeling As shown in Figure 5, we report perplexity on the validation set for the language models based on Transformer and RetNet. We present the scaling curves with three model sizes, i.e., 1.3B, 2.7B, and 6.7B. RetNet achieves comparable results with Transformers. More importantly, the results indicate that RetNet is favorable regarding size scaling. Besides performance, the RetNet training is quite stable in our experiments. Experimental results show that RetNet is a strong competitor to Transformer for large language models. Empirically, we find that RetNet starts to outperform Transformer when the model size is larger than 2B. We also summarize the language modeling results with different context lengths in Appendix B. We find that appending the <bos> token at the beginning benefits training stability and performance. --- --HS BoolQ COPA PIQA Winograd Winogrande SC Avg Zero-Shot Transformer 55.9 62.0 69.0 74.6 69.5 56.5 75.0 66.RetNet 60.7 62.2 77.0 75.4 77.2 58.1 76.0 69.4-Shot Transformer 55.8 58.7 71.0 75.0 719 57.3 715.4 66.RetNet 60.5 60.1 78.0 76.0 77.9 59.9 75.9 69.Table 3: Zero-shot and few-shot learning with Transformer and RetNet. The model size is 6.7B. . Memory (GB) | Throughput (wps) t Model Size Trm Trm+FlashAttn§ RetNet Trm Trm+FlashAttn RetNet 1.3B 74.8 38.8 34.5 10832.4 63965.2 73344.2.7B 69.6 42.1 42.0 5186.0 34990.2 38921.6.7B 69.0 51.4 48.0 2754.4 16230.1 17458.13B 61.4 46.3 45.9 1208.9 7945.1 8642.Table 4: Training cost of Transformer (Trm), Transformer with FlashAttention (Irm+FlashAttn), and RetNet. We report memory consumption and training throughput (word per second; wps). Zero-Shot and Few-Shot Evaluation on Downstream Tasks We also compare the language models on a wide range of downstream tasks. We evaluate zero-shot and 4-shot learning with the 6.7B models. As shown in Table 3, the datasets include HellaSwag (HS) [ZHB* 19], BoolQ [CLC* 19], COPA [WPN* 19], PIQA [BZB* 20], Winograd, Winogrande [LDM 12], and StoryCloze (SC) [MRL* 17]. The accuracy numbers are consistent with language modeling perplexity presented in Figure 5. RetNet achieves comparable performance with Transformer on zero-shot and in-context learning settings. 3.3. Training Cost As shown in Table 4, we compare the training speed and memory consumption of Transformer and RetNet, where the training sequence length is 8192. We also compare with FlashAttention [DFE* 22], which improves speed and reduces GPU memory IO by recomputation and kernel fusion. In comparison, we implement RetNet using vanilla PyTorch code, and leave kernel fusion or FlashAttention-like acceleration for future work. We use chunkwise recurrent representation of retention as described in Equation (7). The chunk size is set to 512. We evaluate the results with eight Nvidia A100-80GB GPUs, because FlashAttention is highly optimized for A100. Tensor parallelism is enabled for 6.7B and 13B models. Experimental results show that RetNet is more memory-efficient and has higher throughput than Transformers during training. Even compared with FlashAttention, RetNet is still competitive in terms of speed and memory cost. Moreover, without relying on specific kernels, it is easy to train RetNet on other platforms efficiently. For example, we train the RetNet models on an AMD MIcluster with decent throughput. It is notable that RetNet has the potential to further reduce cost via advanced implementation, such as kernel fusion. 3.4 Inference Cost As shown in Figure 6, we compare memory cost, throughput, and latency of Transformer and RetNet during inference. Transformers reuse KV caches of previously decoded tokens. RetNet uses the recurrent representation as described in Equation (6). We evaluate the 6.7B model on the A100-80GB GPU in our experiments. Figure 6 shows that RetNet outperforms Transformer in terms of inference cost. Memory As shown in Figure 6a, the memory cost of Transformer increases linearly due to KV caches. In contrast, the memory consumption of RetNet remains consistent even for long sequences, --- -----. Model Weights ad a 45 9 Pia—— RetNetwo 40) =.= Transformer v7” =oO o a z = 2 a =8 30 ae 3 —— RetNet 7) o £ =e= Transformer = o D35 25 o ° a o* = G 49 F100} — ~ wee 15 50 Tae ee c 4 * 2048 3072 4096 5120 6144 7168 8192 2048 3072 4096 5120 6144 7168Sequence Length Sequence Length (a) GPU memory cost of Transformer and RetNet. (b) Throughput of Transformer and RetNet. -_350 =—e= Transformer (1024) c =e= Transformer (2048) o” 300] —2= Transformer (4096) »% ? 250| “*= Transformer (8192)z === RetNet (8192) 4 ° & 200 7 Ler 2 7 ~ 7 150 Pa --" + cad “ o - “—--1004 -- — ee ew Ke Bre ee ee 50| ==eSe-—77™ rs H N w 4 5 6 7Batch Size (c) Inference latency with different batch sizes. Figure 6: Inference cost of Transformer and RetNet with a model size of 6.7B. RetNet outperforms Transformers in terms of memory consumption, throughput, and latency. requiring much less GPU memory to host RetNet. The additional memory consumption of RetNet is almost negligible (i.e., about 3%) while the model weights occupy 97%. Throughput As presented in Figure 6b, the throughput of Transformer drops along with the decoding length increases. In comparison, RetNet has higher and length-invariant throughput during decoding, by utilizing the recurrent representation of retention. Latency Latency is an important metric in deployment, which greatly affects user experience. We report decoding latency in Figure 6c. Experimental results show that increasing batch size renders Transformer’s latency larger. Moreover, the latency of Transformers grows faster with longer input. In order to make latency acceptable, we have to restrict the batch size, which harms the overall inference throughput of Transformers. By contrast, RetNet’s decoding latency outperforms Transformers and keeps almost the same across different batch sizes and input lengths. 3.5 Comparison with Transformer Variants Apart from Transformer, we compare RetNet with various efficient Transformer variants, including Linear Transformer [K VPF20], RWKV [PAA* 23], H3 [DFS+22], and Hyena [PMN*23]. All models have 200M parameters with 16 layers and a hidden dimension of 1024. For H3, we set the head dimension as 8. For RWKV, we use the TimeMix module to substitute self-attention layers while keeping FFN layers consistent with other models for fair comparisons. We train the models with 10k steps with a batch size of 0.5M tokens. Most hyperparameters and training corpora are kept the same as in Section 3.1. Table 5 reports the perplexity numbers on the in-domain validation set and other out-of-domain corpora, e.g., Project Gutenberg 2019-2022 (PG22) [SDP* 22], QMSum [ZYY*21], GovRe --- --Method In-Domain | PG22. QMSum_ GovReport SummScreen RWKV 30.92 51.41 28.17 19.80 25.H3 29.97 49.17 24.29 19.19 25.Hyena 32.08 52.75 28.18 20.55 26.Linear Transformer 40.24 63.86 28.45 25.33 32.RetNet 26.05 45.27 21.33 16.52 22.Table 5: Perplexity results on language modeling. RetNet outperforms other architectures on both the in-domain evaluation set and various out-of-domain corpora. Method In-Domain | PG22.| QMSum_ GovReport SummScreen RetNet 26.05 45.27 21.33 16.52 22.— swish gate 27.84 49.44 22.52 17.45 23.— GroupNorm 27.54 46.95 22.61 17.59 23.— 7 decay 27.86 47.85 21.99 17.49 23.— multi-scale decay 27.02 47.18 22.08 17.17 23.Reduce head dimension 27.68 47.72 23.09 17.46 23.Table 6: Ablation results on in-domain and out-of-domain corpora. port [HCP*21], SummScreen [CCWG21, SSI* 22]. Overall, RetNet outperforms previous methods across different datasets. RetNet not only achieves better evaluation results on the in-domain corpus but also obtains lower perplexity on several out-of-domain datasets. The favorable performance makes RetNet a strong successor to Transformer, besides the benefits of significant cost reduction (Sections 3.3 and 3.4). In addition, we discuss the training and inference efficiency of the compared methods. Let d denote the hidden dimension, and n the sequence length. For training, RWKV’s token-mixing complexity is O(dn) while Hyena’s is O(dn log n) with Fast Fourier Transform acceleration. The above two methods reduce training FLOPS via employing element-wise operators to trade-off modeling capacity. In comparison with retention, the chunk-wise recurrent representation is O(dn(b + h)), where b is the chunk size, h is the head dimension, and we usually set b = 512, h = 256. For either large model size (i.e., larger d) or sequence length, the additional b + h has negligible effects. So the RetNet training is quite efficient without sacrificing the modeling performance. For inference, among the compared efficient architectures, Hyena has the same complexity (i.e., O(m) per step) as Transformer while the others can perform O(1) decoding. 3.6 Ablation Studies We ablate various design choices of RetNet and report the language modeling results in Table 6. The evaluation settings and metrics are the same as in Section 3.5. Architecture We ablate the swish gate and GroupNorm as described in Equation (8). Tableshows that the above two components improve the final performance. Firstly, the gating module is essential for enhancing non-linearity and improving model capability. Notice that we use the same parameter allocation as Transformers after removing the gate. Secondly, group normalization in retention balances the variances of multi-head outputs, which improves training stability and language modeling results. Multi-Scale Decay Equation (8) shows that we use different 7 as the decay rates for the retention heads. In the ablation studies, we examine removing y decay (i.e., “— -y decay”) and applying the same decay rate across heads (i.e., “— multi-scale decay”). Specifically, ablating 7 decay is equivalent to y = 1. In the second setting, we set y = 127/128 for all heads. Table 6 indicates that both the decay mechanism and using multiple decay rates can improve the language modeling performance. Head Dimension From the recurrent perspective of Equation (1), the head dimension implies the memory capacity of hidden states. In the ablation study, we reduce the default head dimension from--- --256 to 64, i.e., 64 for queries and keys, and 128 for values. We keep the hidden dimension dmodei the same so the number of heads increases. Experimental results in Table 6 show that the larger head dimension achieves better performance. 4
--- CONCLUSION ---
In this work, we propose retentive networks (RetNet) for sequence modeling, which enables various representations, i.e., parallel, recurrent, and chunkwise recurrent. RetNet achieves significantly better inference efficiency (in terms of memory, speed, and latency), favorable training parallelization, and competitive performance compared with Transformers. The above advantages make RetNet an ideal successor to Transformers for large language models, especially considering the deployment benefits brought by the O(1) inference complexity. In the future, we would like to scale up RetNet in terms of model size [CDH* 22] and training steps. Moreover, retention can efficiently work with structured prompting [HSD* 22b] by compressing long-term memory. We will also use RetNet as the backbone architecture to train multimodal large language models [HSD* 22a, HDW*23, PWD* 23]. In addition, we are interested in deploying RetNet models on various edge devices, such as mobile phones. Acknowledgement We would like to acknowledge Jiayu Ding, Songlin Yang, and colleagues from MSRA System Group for the helpful discussions. References [BKH16] Jimmy Lei Ba, Jamie Ryan Kiros, and Geoffrey E Hinton. Layer normalization. arXiv preprint arXiv: 1607.06450, 2016. [BMR*20] Tom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal, Ariel Herbert-Voss, Gretchen Krueger, Tom Henighan, Rewon Child, Aditya Ramesh, Daniel Ziegler, Jeffrey Wu, Clemens Winter, Chris Hesse, Mark Chen, Eric Sigler, Mateusz Litwin, Scott Gray, Benjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec Radford, Ilya Sutskever, and Dario Amodei. Language models are few-shot learners. In Advances in Neural Information Processing Systems, volume 33, pages 1877-1901. Curran Associates, Inc., 2020. {[BZB*20] Yonatan Bisk, Rowan Zellers, Ronan Le Bras, Jianfeng Gao, and Yejin Choi. Piqa: Reasoning about physical commonsense in natural language. In Thirty-Fourth AAAI Conference on Artificial Intelligence, 2020. [CCWG21] Mingda Chen, Zewei Chu, Sam Wiseman, and Kevin Gimpel. Summscreen: A dataset for abstractive screenplay summarization. arXiv preprint arXiv:2104.07091, 2021. [CDH* 22] Zewen Chi, Li Dong, Shaohan Huang, Damai Dai, Shuming Ma, Barun Patra, Saksham Singhal, Payal Bajaj, Xia Song, Xian-Ling Mao, Heyan Huang, and Furu Wei. On the representation collapse of sparse mixture of experts. In Advances in Neural Information Processing Systems, 2022. [CLC+19] Christopher Clark, Kenton Lee, Ming-Wei Chang, Tom Kwiatkowski, Michael Collins, and Kristina Toutanova. BoolQ: Exploring the surprising difficulty of natural yes/no questions. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics, pages 2924-2936, 2019. [DFE*t 22] Tri Dao, Dan Fu, Stefano Ermon, Atri Rudra, and Christopher Ré. Flashattention: Fast and memory-efficient exact attention with io-awareness. Advances in Neural Information Processing Systems, 35:16344—16359, 2022. [DFS+22] Tri Dao, Daniel Y Fu, Khaled K Saab, Armin W Thomas, Atri Rudra, and Christopher Ré. Hungry hungry hippos: Towards language modeling with state space models. arXiv preprint arXiv:2212.14052, 2022.--- --[DMI*[GBB*[GGR[HCPt[HDW*[HG[HS[HSD*22a [HSD*22b [KLBA*[KVPF[LDM[LH[MRL*[MWH*[OSG*Jesse Dodge, Ana Marasovié, Gabriel Ilharco, Dirk Groeneveld, Margaret Mitchell, and Matt Gardner. Documenting large webtext corpora: A case study on the colossal clean crawled corpus. In Conference on Empirical Methods in Natural Language Processing, 2021. Leo Gao, Stella Biderman, Sid Black, Laurence Golding, Travis Hoppe, Charles Foster, Jason Phang, Horace He, Anish Thite, Noa Nabeshima, et al. The Pile: An 800GB dataset of diverse text for language modeling. arXiv preprint arXiv:2101.00027, 2020. Albert Gu, Karan Goel, and Christopher Ré. Efficiently modeling long sequences with structured state spaces. arXiv preprint arXiv:2111.00396, 2021. Luyang Huang, Shuyang Cao, Nikolaus Parulian, Heng Ji, and Lu Wang. Efficient attentions for long document summarization. arXiv preprint arXiv:2104.02112, 2021. Shaohan Huang, Li Dong, Wenhui Wang, Yaru Hao, Saksham Singhal, Shuming Ma, Tengchao Ly, Lei Cui, Owais Khan Mohammed, Qiang Liu, Kriti Aggarwal, Zewen Chi, Johan Bjorck, Vishrav Chaudhary, Subhojit Som, Xia Song, and Furu Wei. Language is not all you need: Aligning perception with language models. ArXiv, abs/2302.14045, 2023. Dan Hendrycks and Kevin Gimpel. Gaussian error linear units (GELUs). arXiv: Learning, 2016. Sepp Hochreiter and Jiirgen Schmidhuber. Long short-term memory. Neural Computation, 9:1735-1780, November 1997. Yaru Hao, Haoyu Song, Li Dong, Shaohan Huang, Zewen Chi, Wenhui Wang, Shuming Ma, and Furu Wei. Language models are general-purpose interfaces. ArXiv, abs/2206.06336, 2022. Yaru Hao, Yutao Sun, Li Dong, Zhixiong Han, Yuxian Gu, and Furu Wei. Structured prompting: Scaling in-context learning to 1,000 examples. ArXiv, abs/2212.06713, 2022. Denis Kocetkov, Raymond Li, Loubna Ben Allal, Jia Li, Chenghao Mou, Carlos Mufioz Ferrandis, Yacine Jernite, Margaret Mitchell, Sean Hughes, Thomas Wolf, Dzmitry Bahdanau, Leandro von Werra, and Harm de Vries. The Stack: 3TB of permissively licensed source code. Preprint, 2022. Angelos Katharopoulos, Apoorv Vyas, Nikolaos Pappas, and Francois Fleuret. Transformers are rnns: Fast autoregressive transformers with linear attention. In International Conference on Machine Learning, pages 5156-5165. PMLR, 2020. Hector Levesque, Ernest Davis, and Leora Morgenstern. The winograd schema challenge. In Thirteenth International Conference on the Principles of Knowledge Representation and Reasoning, 2012. Ilya Loshchilov and Frank Hutter. Decoupled weight decay regularization. In International Conference on Learning Representations, 2019. Nasrin Mostafazadeh, Michael Roth, Annie Louis, Nathanael Chambers, and James Allen. Lsdsem 2017 shared task: The story cloze test. In Proceedings of the 2nd Workshop on Linking Models of Lexical, Sentential and Discourse-level Semantics, pages 46-51, 2017. Shuming Ma, Hongyu Wang, Shaohan Huang, Wenhui Wang, Zewen Chi, Li Dong, Alon Benhaim, Barun Patra, Vishrav Chaudhary, Xia Song, and Furu Wei. TorchScale: Transformers at scale. CoRR, abs/2211.13184, 2022. Antonio Orvieto, Samuel L. Smith, Albert Gu, Anushan Fernando, Caglar Gulcehre, Razvan Pascanu, and Soham De. Resurrecting recurrent neural networks for long sequences. ArXiv, abs/2303.06349, 2023.--- --[PAA* 23] [PMN*[PWD*[RZL[SDP*[Shal[SLP*[SPP*[SSI*[VSP*[WH[WMD*[WMH*[WPN*[ZHB*[ZYY*Bo Peng, Eric Alcaide, Quentin Anthony, Alon Albalak, Samuel Arcadinho, Huanqi Cao, Xin Cheng, Michael Chung, Matteo Grella, Kranthi Kiran GV, Xuzheng He, Haowen Hou, Przemyslaw Kazienko, Jan Kocon, Jiaming Kong, Bartlomiej Koptyra, Hayden Lau, Krishna Sri Ipsit Mantri, Ferdinand Mom, Atsushi Saito, Xiangru Tang, Bolun Wang, Johan S. Wind, Stansilaw Wozniak, Ruichong Zhang, Zhenyuan Zhang, Qihang Zhao, Peng Zhou, Jian Zhu, and Rui-Jie Zhu. Rwkv: Reinventing rnns for the transformer era, 2023. Michael Poli, Stefano Massaroli, Eric Nguyen, Daniel Y Fu, Tri Dao, Stephen Baccus, Yoshua Bengio, Stefano Ermon, and Christopher Ré. Hyena hierarchy: Towards larger convolutional language models. arXiv preprint arXiv:2302.10866, 2023. Zhiliang Peng, Wenhui Wang, Li Dong, Yaru Hao, Shaohan Huang, Shuming Ma, and Furu Wei. Kosmos-2: Grounding multimodal large language models to the world. ArXiv, abs/2306.14824, 2023. Prajit Ramachandran, Barret Zoph, and Quoc V. Le. Swish: a self-gated activation function. arXiv: Neural and Evolutionary Computing, 2017. Yutao Sun, Li Dong, Barun Patra, Shuming Ma, Shaohan Huang, Alon Benhaim, Vishrav Chaudhary, Xia Song, and Furu Wei. A length-extrapolatable transformer. arXiv preprint arXiv:2212.10554, 2022. Noam M. Shazeer. Fast transformer decoding: One write-head is all you need. ArXiv, abs/1911.02150, 2019. Jianlin Su, Yu Lu, Shengfeng Pan, Bo Wen, and Yunfeng Liu. Roformer: Enhanced transformer with rotary position embedding. arXiv preprint arXiv:2104.09864, 2021. Mohammad Shoeybi, Mostofa Patwary, Raul Puri, Patrick LeGresley, Jared Casper, and Bryan Catanzaro. Megatron-LM: Training multi-billion parameter language models using model parallelism. arXiv preprint arXiv: 1909.08053, 2019. Uri Shaham, Elad Segal, Maor Ivgi, Avia Efrat, Ori Yoran, Adi Haviv, Ankit Gupta, Wenhan Xiong, Mor Geva, Jonathan Berant, et al. Scrolls: Standardized comparison over long language sequences. arXiv preprint arXiv:2201.03533, 2022. Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, and Ilia Polosukhin. Attention is all you need. In Advances in Neural Information Processing Systems 30: Annual Conference on Neural Information Processing Systems 2017, 4-9 December 2017, Long Beach, CA, USA, pages 6000— 6010, 2017. Yuxin Wu and Kaiming He. Group normalization. In Proceedings of the European conference on computer vision (ECCV), pages 3-19, 2018. Hongyu Wang, Shuming Ma, Li Dong, Shaohan Huang, Dongdong Zhang, and Furu Wei. DeepNet: Scaling Transformers to 1,000 layers. ArXiv, abs/2203.00555, 2022. Hongyu Wang, Shuming Ma, Shaohan Huang, Li Dong, Wenhui Wang, Zhiliang Peng, Yu Wu, Payal Bajaj, Saksham Singhal, Alon Benhaim, et al. Foundation transformers. arXiv preprint arXiv:2210.06423, 2022. Alex Wang, Yada Pruksachatkun, Nikita Nangia, Amanpreet Singh, Julian Michael, Felix Hill, Omer Levy, and Samuel R Bowman. SuperGLUE: A stickier benchmark for general-purpose language understanding systems. arXiv preprint arXiv: 1905.00537, 2019. Rowan Zellers, Ari Holtzman, Yonatan Bisk, Ali Farhadi, and Yejin Choi. Hellaswag: Can a machine really finish your sentence? In Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, 2019. Ming Zhong, Da Yin, Tao Yu, Ahmad Zaidi, Mutethia Mutuma, Rahul Jha, Ahmed Hassan Awadallah, Asli Celikyilmaz, Yang Liu, Xipeng Qiu, et al. Qmsum: A new benchmark for query-based multi-domain meeting summarization. arXiv preprint arXiv:2104.05938, 2021.--- --A Hyperparameters Hyperparameters 1.3B 2.7B 6.7B Layers 24 32Hidden size 2048 2560FEN size 4096 5120Heads 8 10Learning rate 6x10-* 3x10-4 3xLR scheduler Polynomial decay Warm-up stepsTokens per batch 4M. Adam (0.9, 0.98) Training steps 25,Gradient clipping 2.Dropout 0.Weight decay 0.Table 7: Hyperparamters used for the models in Section 3. B_ Grouped Results of Different Context Lengths As shown in Table 8, we report language modeling results with different context lengths. In order to make the numbers comparable, we use 2048 text chunks as evaluation data and only compute perplexity for the last 128 tokens. Experimental results show that RetNet outperforms Transformer across different context lengths. Besides, RetNet can utilize longer context for better results. Model 512 1024 =Transformer 13.55 12.56 12.RetNet 13.09 12.14 11.Table 8: Language modeling perplexity of RetNet and Transformer with different context length. The results show that RetNet has a consistent advantage across sequence length.
